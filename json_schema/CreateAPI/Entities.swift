// Generated by Create API
// https://github.com/CreateAPI/CreateAPI
//
// swiftlint:disable all

import Foundation

public enum AddOrDeleteRulesRequest: Codable {
    case addRulesRequest(AddRulesRequest)
    case deleteRulesRequest(DeleteRulesRequest)

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let value = try? container.decode(AddRulesRequest.self) {
            self = .addRulesRequest(value)
        } else if let value = try? container.decode(DeleteRulesRequest.self) {
            self = .deleteRulesRequest(value)
        } else {
            throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .addRulesRequest(let value): try container.encode(value)
        case .deleteRulesRequest(let value): try container.encode(value)
        }
    }
}

/// A response from modifying user-specified stream filtering rules.
public struct AddOrDeleteRulesResponse: Codable {
    /// All user-specified stream filtering rules that were created.
    public var data: [Rule]?
    public var errors: [Problem]?
    public var meta: RulesResponseMetadata

    public init(data: [Rule]? = nil, errors: [Problem]? = nil, meta: RulesResponseMetadata) {
        self.data = data
        self.errors = errors
        self.meta = meta
    }
}

/// A request to add a user-specified stream filtering rule.
public struct AddRulesRequest: Codable {
    public var add: [RuleNoID]

    public init(add: [RuleNoID]) {
        self.add = add
    }
}

public struct AnimatedGif: Codable {
    public var media: Media
    public var previewImageURL: URL?
    /// An array of all available variants of the media.
    public var variants: [Variant]?

    public init(media: Media, previewImageURL: URL? = nil, variants: [Variant]? = nil) {
        self.media = media
        self.previewImageURL = previewImageURL
        self.variants = variants
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.media = try Media(from: decoder)
        self.previewImageURL = try values.decodeIfPresent(URL.self, forKey: "preview_image_url")
        self.variants = try values.decodeIfPresent([Variant].self, forKey: "variants")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(media, forKey: "media")
        try values.encodeIfPresent(previewImageURL, forKey: "preview_image_url")
        try values.encodeIfPresent(variants, forKey: "variants")
    }
}

public struct BlockUserMutationResponse: Codable {
    public var data: Data?
    public var errors: [Problem]?

    public struct Data: Codable {
        public var isBlocking: Bool?

        public init(isBlocking: Bool? = nil) {
            self.isBlocking = isBlocking
        }

        private enum CodingKeys: String, CodingKey {
            case isBlocking = "blocking"
        }
    }

    public init(data: Data? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

public struct BlockUserRequest: Codable {
    /// Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
    ///
    /// Example: "2244994945"
    public var targetUserID: String

    public init(targetUserID: String) {
        self.targetUserID = targetUserID
    }

    private enum CodingKeys: String, CodingKey {
        case targetUserID = "target_user_id"
    }
}

public struct BookmarkAddRequest: Codable {
    /// Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
    ///
    /// Example: "1346889436626259968"
    public var tweetID: String

    public init(tweetID: String) {
        self.tweetID = tweetID
    }

    private enum CodingKeys: String, CodingKey {
        case tweetID = "tweet_id"
    }
}

public struct BookmarkMutationResponse: Codable {
    public var data: Data?
    public var errors: [Problem]?

    public struct Data: Codable {
        public var isBookmarked: Bool?

        public init(isBookmarked: Bool? = nil) {
            self.isBookmarked = isBookmarked
        }

        private enum CodingKeys: String, CodingKey {
            case isBookmarked = "bookmarked"
        }
    }

    public init(data: Data? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

public struct CashtagEntity: Codable {
    /// Represent a boundary range (start and end index) for a recognized entity (for example a hashtag or a mention). `start` must be smaller than `end`.  The start index is inclusive, the end index is exclusive.
    public var entityIndicesInclusiveExclusive: EntityIndicesInclusiveExclusive
    /// Represent the portion of text recognized as a Cashtag, and its start and end position within the text.
    public var cashtagFields: CashtagFields

    public init(entityIndicesInclusiveExclusive: EntityIndicesInclusiveExclusive, cashtagFields: CashtagFields) {
        self.entityIndicesInclusiveExclusive = entityIndicesInclusiveExclusive
        self.cashtagFields = cashtagFields
    }

    public init(from decoder: Decoder) throws {
        self.entityIndicesInclusiveExclusive = try EntityIndicesInclusiveExclusive(from: decoder)
        self.cashtagFields = try CashtagFields(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(entityIndicesInclusiveExclusive, forKey: "entityIndicesInclusiveExclusive")
        try values.encode(cashtagFields, forKey: "cashtagFields")
    }
}

/// Represent the portion of text recognized as a Cashtag, and its start and end position within the text.
public struct CashtagFields: Codable {
    /// Example: "TWTR"
    public var tag: String

    public init(tag: String) {
        self.tag = tag
    }
}

/// A problem that indicates your client is forbidden from making this request.
public struct ClientForbiddenProblem: Codable {
    /// An HTTP Problem Details object, as defined in IETF RFC 7807 (https://tools.ietf.org/html/rfc7807).
    public var problem: Problem
    public var reason: Reason?
    public var registrationURL: URL?

    public enum Reason: String, Codable, CaseIterable {
        case officialClientForbidden = "official-client-forbidden"
        case clientNotEnrolled = "client-not-enrolled"
    }

    public init(problem: Problem, reason: Reason? = nil, registrationURL: URL? = nil) {
        self.problem = problem
        self.reason = reason
        self.registrationURL = registrationURL
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.problem = try Problem(from: decoder)
        self.reason = try values.decodeIfPresent(Reason.self, forKey: "reason")
        self.registrationURL = try values.decodeIfPresent(URL.self, forKey: "registration_url")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(problem, forKey: "problem")
        try values.encodeIfPresent(reason, forKey: "reason")
        try values.encodeIfPresent(registrationURL, forKey: "registration_url")
    }
}

public struct ComplianceJob: Codable {
    /// Creation time of the compliance job.
    ///
    /// Example: "2021-01-06T18:40:40.000Z"
    public var createdAt: Date
    /// Expiration time of the download URL.
    ///
    /// Example: "2021-01-06T18:40:40.000Z"
    public var downloadExpiresAt: Date
    /// URL from which the user will retrieve their compliance results.
    public var downloadURL: URL
    /// Compliance Job ID.
    ///
    /// Example: "1372966999991541762"
    public var id: String
    /// User-provided name for a compliance job.
    ///
    /// Example: "my-job"
    public var name: String?
    /// Status of a compliance job.
    public var status: ComplianceJobStatus
    /// Type of compliance job to list.
    public var type: ComplianceJobType
    /// Expiration time of the upload URL.
    ///
    /// Example: "2021-01-06T18:40:40.000Z"
    public var uploadExpiresAt: Date
    /// URL to which the user will upload their Tweet or user IDs.
    public var uploadURL: URL

    public init(createdAt: Date, downloadExpiresAt: Date, downloadURL: URL, id: String, name: String? = nil, status: ComplianceJobStatus, type: ComplianceJobType, uploadExpiresAt: Date, uploadURL: URL) {
        self.createdAt = createdAt
        self.downloadExpiresAt = downloadExpiresAt
        self.downloadURL = downloadURL
        self.id = id
        self.name = name
        self.status = status
        self.type = type
        self.uploadExpiresAt = uploadExpiresAt
        self.uploadURL = uploadURL
    }

    private enum CodingKeys: String, CodingKey {
        case createdAt = "created_at"
        case downloadExpiresAt = "download_expires_at"
        case downloadURL = "download_url"
        case id
        case name
        case status
        case type
        case uploadExpiresAt = "upload_expires_at"
        case uploadURL = "upload_url"
    }
}

/// Status of a compliance job.
public enum ComplianceJobStatus: String, Codable, CaseIterable {
    case created
    case inProgress = "in_progress"
    case failed
    case complete
    case expired
}

/// Type of compliance job to list.
public enum ComplianceJobType: String, Codable, CaseIterable {
    case tweets
    case users
}

/// A problem that indicates something is wrong with the connection.
public struct ConnectionExceptionProblem: Codable {
    /// An HTTP Problem Details object, as defined in IETF RFC 7807 (https://tools.ietf.org/html/rfc7807).
    public var problem: Problem
    public var connectionIssue: ConnectionIssue?

    public enum ConnectionIssue: String, Codable, CaseIterable {
        case tooManyConnections = "TooManyConnections"
        case provisioningSubscription = "ProvisioningSubscription"
        case ruleConfigurationIssue = "RuleConfigurationIssue"
        case rulesInvalidIssue = "RulesInvalidIssue"
    }

    public init(problem: Problem, connectionIssue: ConnectionIssue? = nil) {
        self.problem = problem
        self.connectionIssue = connectionIssue
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.problem = try Problem(from: decoder)
        self.connectionIssue = try values.decodeIfPresent(ConnectionIssue.self, forKey: "connection_issue")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(problem, forKey: "problem")
        try values.encodeIfPresent(connectionIssue, forKey: "connection_issue")
    }
}

/// Annotation inferred from the Tweet text.
public struct ContextAnnotation: Codable {
    /// Represents the data for the context annotation domain.
    public var domain: ContextAnnotationDomainFields
    /// Represents the data for the context annotation entity.
    public var entity: ContextAnnotationEntityFields

    public init(domain: ContextAnnotationDomainFields, entity: ContextAnnotationEntityFields) {
        self.domain = domain
        self.entity = entity
    }
}

/// Represents the data for the context annotation domain.
public struct ContextAnnotationDomainFields: Codable {
    /// Description of the context annotation domain.
    public var description: String?
    /// The unique id for a context annotation domain.
    public var id: String
    /// Name of the context annotation domain.
    public var name: String?

    public init(description: String? = nil, id: String, name: String? = nil) {
        self.description = description
        self.id = id
        self.name = name
    }
}

/// Represents the data for the context annotation entity.
public struct ContextAnnotationEntityFields: Codable {
    /// Description of the context annotation entity.
    public var description: String?
    /// The unique id for a context annotation entity.
    public var id: String
    /// Name of the context annotation entity.
    public var name: String?

    public init(description: String? = nil, id: String, name: String? = nil) {
        self.description = description
        self.id = id
        self.name = name
    }
}

/// A request to create a new batch compliance job.
public struct CreateComplianceJobRequest: Codable {
    /// User-provided name for a compliance job.
    ///
    /// Example: "my-job"
    public var name: String?
    /// If true, this endpoint will return a pre-signed URL with resumable uploads enabled.
    public var isResumable: Bool?
    /// Type of compliance job to list.
    public var type: `Type`

    /// Type of compliance job to list.
    public enum `Type`: String, Codable, CaseIterable {
        case tweets
        case users
    }

    public init(name: String? = nil, isResumable: Bool? = nil, type: `Type`) {
        self.name = name
        self.isResumable = isResumable
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case isResumable = "resumable"
        case type
    }
}

public struct CreateComplianceJobResponse: Codable {
    public var data: ComplianceJob?
    public var errors: [Problem]?

    public init(data: ComplianceJob? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

/// A response from deleting user-specified stream filtering rules.
public struct DeleteRulesRequest: Codable {
    /// IDs and values of all deleted user-specified stream filtering rules.
    public var delete: Delete

    /// IDs and values of all deleted user-specified stream filtering rules.
    public struct Delete: Codable {
        /// IDs of all deleted user-specified stream filtering rules.
        public var ids: [String]?
        /// Values of all deleted user-specified stream filtering rules.
        public var values: [String]?

        public init(ids: [String]? = nil, values: [String]? = nil) {
            self.ids = ids
            self.values = values
        }
    }

    public init(delete: Delete) {
        self.delete = delete
    }
}

/// A problem that indicates that the resource requested violates the precepts of this API.
public struct DisallowedResourceProblem: Codable {
    /// An HTTP Problem Details object, as defined in IETF RFC 7807 (https://tools.ietf.org/html/rfc7807).
    public var problem: Problem
    public var resourceID: String
    public var resourceType: ResourceType
    public var section: Section

    public enum ResourceType: String, Codable, CaseIterable {
        case user
        case tweet
        case media
        case list
        case space
    }

    public enum Section: String, Codable, CaseIterable {
        case data
        case includes
    }

    public init(problem: Problem, resourceID: String, resourceType: ResourceType, section: Section) {
        self.problem = problem
        self.resourceID = resourceID
        self.resourceType = resourceType
        self.section = section
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.problem = try Problem(from: decoder)
        self.resourceID = try values.decode(String.self, forKey: "resource_id")
        self.resourceType = try values.decode(ResourceType.self, forKey: "resource_type")
        self.section = try values.decode(Section.self, forKey: "section")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(problem, forKey: "problem")
        try values.encode(resourceID, forKey: "resource_id")
        try values.encode(resourceType, forKey: "resource_type")
        try values.encode(section, forKey: "section")
    }
}

/// The rule you have submitted is a duplicate.
public struct DuplicateRuleProblem: Codable {
    /// An HTTP Problem Details object, as defined in IETF RFC 7807 (https://tools.ietf.org/html/rfc7807).
    public var problem: Problem
    public var id: String?
    public var value: String?

    public init(problem: Problem, id: String? = nil, value: String? = nil) {
        self.problem = problem
        self.id = id
        self.value = value
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.problem = try Problem(from: decoder)
        self.id = try values.decodeIfPresent(String.self, forKey: "id")
        self.value = try values.decodeIfPresent(String.self, forKey: "value")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(problem, forKey: "problem")
        try values.encodeIfPresent(id, forKey: "id")
        try values.encodeIfPresent(value, forKey: "value")
    }
}

/// Represent a boundary range (start and end index) for a recognized entity (for example a hashtag or a mention). `start` must be smaller than `end`.  The start index is inclusive, the end index is exclusive.
public struct EntityIndicesInclusiveExclusive: Codable {
    /// Index (zero-based) at which position this entity ends.  The index is exclusive.
    ///
    /// Example: 61
    public var end: Int
    /// Index (zero-based) at which position this entity starts.  The index is inclusive.
    ///
    /// Example: 50
    public var start: Int

    public init(end: Int, start: Int) {
        self.end = end
        self.start = start
    }
}

/// Represent a boundary range (start and end index) for a recognized entity (for example a hashtag or a mention). `start` must be smaller than `end`.  The start index is inclusive, the end index is inclusive.
public struct EntityIndicesInclusiveInclusive: Codable {
    /// Index (zero-based) at which position this entity ends.  The index is inclusive.
    ///
    /// Example: 61
    public var end: Int
    /// Index (zero-based) at which position this entity starts.  The index is inclusive.
    ///
    /// Example: 50
    public var start: Int

    public init(end: Int, start: Int) {
        self.end = end
        self.start = start
    }
}

public struct Error: Codable {
    public var code: Int
    public var message: String

    public init(code: Int, message: String) {
        self.code = code
        self.message = message
    }
}

public struct Expansions: Codable {
    public var media: [Media]?
    public var places: [Place]?
    public var polls: [Poll]?
    public var topics: [Topic]?
    public var tweets: [Tweet]?
    public var users: [User]?

    public init(media: [Media]? = nil, places: [Place]? = nil, polls: [Poll]? = nil, topics: [Topic]? = nil, tweets: [Tweet]? = nil, users: [User]? = nil) {
        self.media = media
        self.places = places
        self.polls = polls
        self.topics = topics
        self.tweets = tweets
        self.users = users
    }
}

/// A problem that indicates that you are not allowed to see a particular field on a Tweet, User, etc.
public struct FieldUnauthorizedProblem: Codable {
    /// An HTTP Problem Details object, as defined in IETF RFC 7807 (https://tools.ietf.org/html/rfc7807).
    public var problem: Problem
    public var field: String
    public var resourceType: ResourceType
    public var section: Section

    public enum ResourceType: String, Codable, CaseIterable {
        case user
        case tweet
        case media
        case list
        case space
    }

    public enum Section: String, Codable, CaseIterable {
        case data
        case includes
    }

    public init(problem: Problem, field: String, resourceType: ResourceType, section: Section) {
        self.problem = problem
        self.field = field
        self.resourceType = resourceType
        self.section = section
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.problem = try Problem(from: decoder)
        self.field = try values.decode(String.self, forKey: "field")
        self.resourceType = try values.decode(ResourceType.self, forKey: "resource_type")
        self.section = try values.decode(Section.self, forKey: "section")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(problem, forKey: "problem")
        try values.encode(field, forKey: "field")
        try values.encode(resourceType, forKey: "resource_type")
        try values.encode(section, forKey: "section")
    }
}

/// A Tweet or error that can be returned by the streaming Tweet API. The values returned with a successful streamed Tweet includes the user provided rules that the Tweet matched.
public struct FilteredStreamingTweetResponse: Codable {
    /// Example:
    ///
    /// {
    ///   "author_id" : "2244994945",
    ///   "created_at" : "Wed Jan 06 18:40:40 +0000 2021",
    ///   "id" : "1346889436626259968",
    ///   "text" : "Learn how to use the user Tweet timeline and user mention timeline endpoints in the Twitter API v2 to explore Tweet\\u2026 https:\\\/\\\/t.co\\\/56a0vZUx7i"
    /// }
    public var data: Tweet?
    public var errors: [Problem]?
    public var includes: Expansions?
    /// The list of rules which matched the Tweet
    public var matchingRules: [MatchingRule]?

    public struct MatchingRule: Codable {
        /// Unique identifier of this rule.
        ///
        /// Example: "120897978112909812"
        public var id: String
        /// A tag meant for the labeling of user provided rules.
        ///
        /// Example: "Non-retweeted coffee Tweets"
        public var tag: String?

        public init(id: String, tag: String? = nil) {
            self.id = id
            self.tag = tag
        }
    }

    public init(data: Tweet? = nil, errors: [Problem]? = nil, includes: Expansions? = nil, matchingRules: [MatchingRule]? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
        self.matchingRules = matchingRules
    }

    private enum CodingKeys: String, CodingKey {
        case data
        case errors
        case includes
        case matchingRules = "matching_rules"
    }
}

public struct FullTextEntities: Codable {
    public var annotations: [Annotation]?
    public var cashtags: [CashtagEntity]?
    public var hashtags: [HashtagEntity]?
    public var mentions: [MentionEntity]?
    public var urls: [URLEntity]?

    /// Annotation for entities based on the Tweet text.
    public struct Annotation: Codable {
        /// Represent a boundary range (start and end index) for a recognized entity (for example a hashtag or a mention). `start` must be smaller than `end`.  The start index is inclusive, the end index is inclusive.
        public var entityIndicesInclusiveInclusive: EntityIndicesInclusiveInclusive
        /// Text used to determine annotation.
        ///
        /// Example: "Barack Obama"
        public var normalizedText: String?
        /// Confidence factor for annotation type.
        public var probability: Double?
        /// Annotation type.
        ///
        /// Example: "Person"
        public var type: String?

        public init(entityIndicesInclusiveInclusive: EntityIndicesInclusiveInclusive, normalizedText: String? = nil, probability: Double? = nil, type: String? = nil) {
            self.entityIndicesInclusiveInclusive = entityIndicesInclusiveInclusive
            self.normalizedText = normalizedText
            self.probability = probability
            self.type = type
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.entityIndicesInclusiveInclusive = try EntityIndicesInclusiveInclusive(from: decoder)
            self.normalizedText = try values.decodeIfPresent(String.self, forKey: "normalized_text")
            self.probability = try values.decodeIfPresent(Double.self, forKey: "probability")
            self.type = try values.decodeIfPresent(String.self, forKey: "type")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(entityIndicesInclusiveInclusive, forKey: "entityIndicesInclusiveInclusive")
            try values.encodeIfPresent(normalizedText, forKey: "normalized_text")
            try values.encodeIfPresent(probability, forKey: "probability")
            try values.encodeIfPresent(type, forKey: "type")
        }
    }

    public init(annotations: [Annotation]? = nil, cashtags: [CashtagEntity]? = nil, hashtags: [HashtagEntity]? = nil, mentions: [MentionEntity]? = nil, urls: [URLEntity]? = nil) {
        self.annotations = annotations
        self.cashtags = cashtags
        self.hashtags = hashtags
        self.mentions = mentions
        self.urls = urls
    }
}

public struct Geo: Codable {
    /// Example:
    ///
    /// [
    ///   -105.19347500000001,
    ///   39.609729999999999,
    ///   -105.053164,
    ///   39.761974000000002
    /// ]
    public var bbox: [Double]
    /// A [GeoJson Point](https://tools.ietf.org/html/rfc7946#section-3.1.2) geometry object.
    public var geometry: Point?
    public var properties: [String: AnyJSON]
    public var type: `Type`

    public enum `Type`: String, Codable, CaseIterable {
        case feature = "Feature"
    }

    public init(bbox: [Double], geometry: Point? = nil, properties: [String: AnyJSON], type: `Type`) {
        self.bbox = bbox
        self.geometry = geometry
        self.properties = properties
        self.type = type
    }
}

public struct Get2ComplianceJobsIDResponse: Codable {
    public var data: ComplianceJob?
    public var errors: [Problem]?

    public init(data: ComplianceJob? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

public struct Get2ComplianceJobsResponse: Codable {
    public var data: [ComplianceJob]?
    public var errors: [Problem]?
    public var meta: Meta?

    public struct Meta: Codable {
        /// The number of results returned in this response.
        public var resultCount: Int?

        public init(resultCount: Int? = nil) {
            self.resultCount = resultCount
        }

        private enum CodingKeys: String, CodingKey {
            case resultCount = "result_count"
        }
    }

    public init(data: [ComplianceJob]? = nil, errors: [Problem]? = nil, meta: Meta? = nil) {
        self.data = data
        self.errors = errors
        self.meta = meta
    }
}

public struct Get2ListsIDFollowersResponse: Codable {
    public var data: [User]?
    public var errors: [Problem]?
    public var includes: Expansions?
    public var meta: Meta?

    public struct Meta: Codable {
        /// The next token.
        public var nextToken: String?
        /// The previous token.
        public var previousToken: String?
        /// The number of results returned in this response.
        public var resultCount: Int?

        public init(nextToken: String? = nil, previousToken: String? = nil, resultCount: Int? = nil) {
            self.nextToken = nextToken
            self.previousToken = previousToken
            self.resultCount = resultCount
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "next_token"
            case previousToken = "previous_token"
            case resultCount = "result_count"
        }
    }

    public init(data: [User]? = nil, errors: [Problem]? = nil, includes: Expansions? = nil, meta: Meta? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
        self.meta = meta
    }
}

public struct Get2ListsIDMembersResponse: Codable {
    public var data: [User]?
    public var errors: [Problem]?
    public var includes: Expansions?
    public var meta: Meta?

    public struct Meta: Codable {
        /// The next token.
        public var nextToken: String?
        /// The previous token.
        public var previousToken: String?
        /// The number of results returned in this response.
        public var resultCount: Int?

        public init(nextToken: String? = nil, previousToken: String? = nil, resultCount: Int? = nil) {
            self.nextToken = nextToken
            self.previousToken = previousToken
            self.resultCount = resultCount
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "next_token"
            case previousToken = "previous_token"
            case resultCount = "result_count"
        }
    }

    public init(data: [User]? = nil, errors: [Problem]? = nil, includes: Expansions? = nil, meta: Meta? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
        self.meta = meta
    }
}

public struct Get2ListsIDResponse: Codable {
    /// A Twitter List is a curated group of accounts.
    public var data: List?
    public var errors: [Problem]?
    public var includes: Expansions?

    public init(data: List? = nil, errors: [Problem]? = nil, includes: Expansions? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
    }
}

public struct Get2ListsIDTweetsResponse: Codable {
    public var data: [Tweet]?
    public var errors: [Problem]?
    public var includes: Expansions?
    public var meta: Meta?

    public struct Meta: Codable {
        /// The next token.
        public var nextToken: String?
        /// The previous token.
        public var previousToken: String?
        /// The number of results returned in this response.
        public var resultCount: Int?

        public init(nextToken: String? = nil, previousToken: String? = nil, resultCount: Int? = nil) {
            self.nextToken = nextToken
            self.previousToken = previousToken
            self.resultCount = resultCount
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "next_token"
            case previousToken = "previous_token"
            case resultCount = "result_count"
        }
    }

    public init(data: [Tweet]? = nil, errors: [Problem]? = nil, includes: Expansions? = nil, meta: Meta? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
        self.meta = meta
    }
}

public struct Get2SpacesByCreatorIDsResponse: Codable {
    public var data: [Space]?
    public var errors: [Problem]?
    public var includes: Expansions?
    public var meta: Meta?

    public struct Meta: Codable {
        /// The number of results returned in this response.
        public var resultCount: Int?

        public init(resultCount: Int? = nil) {
            self.resultCount = resultCount
        }

        private enum CodingKeys: String, CodingKey {
            case resultCount = "result_count"
        }
    }

    public init(data: [Space]? = nil, errors: [Problem]? = nil, includes: Expansions? = nil, meta: Meta? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
        self.meta = meta
    }
}

public struct Get2SpacesIDBuyersResponse: Codable {
    public var data: [User]?
    public var errors: [Problem]?
    public var includes: Expansions?
    public var meta: Meta?

    public struct Meta: Codable {
        /// The next token.
        public var nextToken: String?
        /// The previous token.
        public var previousToken: String?
        /// The number of results returned in this response.
        public var resultCount: Int?

        public init(nextToken: String? = nil, previousToken: String? = nil, resultCount: Int? = nil) {
            self.nextToken = nextToken
            self.previousToken = previousToken
            self.resultCount = resultCount
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "next_token"
            case previousToken = "previous_token"
            case resultCount = "result_count"
        }
    }

    public init(data: [User]? = nil, errors: [Problem]? = nil, includes: Expansions? = nil, meta: Meta? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
        self.meta = meta
    }
}

public struct Get2SpacesIDResponse: Codable {
    public var data: Space?
    public var errors: [Problem]?
    public var includes: Expansions?

    public init(data: Space? = nil, errors: [Problem]? = nil, includes: Expansions? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
    }
}

public struct Get2SpacesIDTweetsResponse: Codable {
    public var data: [Tweet]?
    public var errors: [Problem]?
    public var includes: Expansions?
    public var meta: Meta?

    public struct Meta: Codable {
        /// The next token.
        public var nextToken: String?
        /// The previous token.
        public var previousToken: String?
        /// The number of results returned in this response.
        public var resultCount: Int?

        public init(nextToken: String? = nil, previousToken: String? = nil, resultCount: Int? = nil) {
            self.nextToken = nextToken
            self.previousToken = previousToken
            self.resultCount = resultCount
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "next_token"
            case previousToken = "previous_token"
            case resultCount = "result_count"
        }
    }

    public init(data: [Tweet]? = nil, errors: [Problem]? = nil, includes: Expansions? = nil, meta: Meta? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
        self.meta = meta
    }
}

public struct Get2SpacesResponse: Codable {
    public var data: [Space]?
    public var errors: [Problem]?
    public var includes: Expansions?

    public init(data: [Space]? = nil, errors: [Problem]? = nil, includes: Expansions? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
    }
}

public struct Get2SpacesSearchResponse: Codable {
    public var data: [Space]?
    public var errors: [Problem]?
    public var includes: Expansions?
    public var meta: Meta?

    public struct Meta: Codable {
        /// The number of results returned in this response.
        public var resultCount: Int?

        public init(resultCount: Int? = nil) {
            self.resultCount = resultCount
        }

        private enum CodingKeys: String, CodingKey {
            case resultCount = "result_count"
        }
    }

    public init(data: [Space]? = nil, errors: [Problem]? = nil, includes: Expansions? = nil, meta: Meta? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
        self.meta = meta
    }
}

public struct Get2TweetsCountsAllResponse: Codable {
    public var data: [SearchCount]?
    public var errors: [Problem]?
    public var meta: Meta?

    public struct Meta: Codable {
        /// The newest id in this response.
        public var newestID: String?
        /// The next token.
        public var nextToken: String?
        /// The oldest id in this response.
        public var oldestID: String?
        /// The sum of results returned in this response.
        public var totalTweetCount: Int?

        public init(newestID: String? = nil, nextToken: String? = nil, oldestID: String? = nil, totalTweetCount: Int? = nil) {
            self.newestID = newestID
            self.nextToken = nextToken
            self.oldestID = oldestID
            self.totalTweetCount = totalTweetCount
        }

        private enum CodingKeys: String, CodingKey {
            case newestID = "newest_id"
            case nextToken = "next_token"
            case oldestID = "oldest_id"
            case totalTweetCount = "total_tweet_count"
        }
    }

    public init(data: [SearchCount]? = nil, errors: [Problem]? = nil, meta: Meta? = nil) {
        self.data = data
        self.errors = errors
        self.meta = meta
    }
}

public struct Get2TweetsCountsRecentResponse: Codable {
    public var data: [SearchCount]?
    public var errors: [Problem]?
    public var meta: Meta?

    public struct Meta: Codable {
        /// The newest id in this response.
        public var newestID: String?
        /// The next token.
        public var nextToken: String?
        /// The oldest id in this response.
        public var oldestID: String?
        /// The sum of results returned in this response.
        public var totalTweetCount: Int?

        public init(newestID: String? = nil, nextToken: String? = nil, oldestID: String? = nil, totalTweetCount: Int? = nil) {
            self.newestID = newestID
            self.nextToken = nextToken
            self.oldestID = oldestID
            self.totalTweetCount = totalTweetCount
        }

        private enum CodingKeys: String, CodingKey {
            case newestID = "newest_id"
            case nextToken = "next_token"
            case oldestID = "oldest_id"
            case totalTweetCount = "total_tweet_count"
        }
    }

    public init(data: [SearchCount]? = nil, errors: [Problem]? = nil, meta: Meta? = nil) {
        self.data = data
        self.errors = errors
        self.meta = meta
    }
}

public struct Get2TweetsFirehoseStreamResponse: Codable {
    /// Example:
    ///
    /// {
    ///   "author_id" : "2244994945",
    ///   "created_at" : "Wed Jan 06 18:40:40 +0000 2021",
    ///   "id" : "1346889436626259968",
    ///   "text" : "Learn how to use the user Tweet timeline and user mention timeline endpoints in the Twitter API v2 to explore Tweet\\u2026 https:\\\/\\\/t.co\\\/56a0vZUx7i"
    /// }
    public var data: Tweet?
    public var errors: [Problem]?
    public var includes: Expansions?

    public init(data: Tweet? = nil, errors: [Problem]? = nil, includes: Expansions? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
    }
}

public struct Get2TweetsIDLikingUsersResponse: Codable {
    public var data: [User]?
    public var errors: [Problem]?
    public var includes: Expansions?
    public var meta: Meta?

    public struct Meta: Codable {
        /// The next token.
        public var nextToken: String?
        /// The previous token.
        public var previousToken: String?
        /// The number of results returned in this response.
        public var resultCount: Int?

        public init(nextToken: String? = nil, previousToken: String? = nil, resultCount: Int? = nil) {
            self.nextToken = nextToken
            self.previousToken = previousToken
            self.resultCount = resultCount
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "next_token"
            case previousToken = "previous_token"
            case resultCount = "result_count"
        }
    }

    public init(data: [User]? = nil, errors: [Problem]? = nil, includes: Expansions? = nil, meta: Meta? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
        self.meta = meta
    }
}

public struct Get2TweetsIDQuoteTweetsResponse: Codable {
    public var data: [Tweet]?
    public var errors: [Problem]?
    public var includes: Expansions?
    public var meta: Meta?

    public struct Meta: Codable {
        /// The next token.
        public var nextToken: String?
        /// The number of results returned in this response.
        public var resultCount: Int?

        public init(nextToken: String? = nil, resultCount: Int? = nil) {
            self.nextToken = nextToken
            self.resultCount = resultCount
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "next_token"
            case resultCount = "result_count"
        }
    }

    public init(data: [Tweet]? = nil, errors: [Problem]? = nil, includes: Expansions? = nil, meta: Meta? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
        self.meta = meta
    }
}

public struct Get2TweetsIDResponse: Codable {
    /// Example:
    ///
    /// {
    ///   "author_id" : "2244994945",
    ///   "created_at" : "Wed Jan 06 18:40:40 +0000 2021",
    ///   "id" : "1346889436626259968",
    ///   "text" : "Learn how to use the user Tweet timeline and user mention timeline endpoints in the Twitter API v2 to explore Tweet\\u2026 https:\\\/\\\/t.co\\\/56a0vZUx7i"
    /// }
    public var data: Tweet?
    public var errors: [Problem]?
    public var includes: Expansions?

    public init(data: Tweet? = nil, errors: [Problem]? = nil, includes: Expansions? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
    }
}

public struct Get2TweetsIDRetweetedByResponse: Codable {
    public var data: [User]?
    public var errors: [Problem]?
    public var includes: Expansions?
    public var meta: Meta?

    public struct Meta: Codable {
        /// The next token.
        public var nextToken: String?
        /// The previous token.
        public var previousToken: String?
        /// The number of results returned in this response.
        public var resultCount: Int?

        public init(nextToken: String? = nil, previousToken: String? = nil, resultCount: Int? = nil) {
            self.nextToken = nextToken
            self.previousToken = previousToken
            self.resultCount = resultCount
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "next_token"
            case previousToken = "previous_token"
            case resultCount = "result_count"
        }
    }

    public init(data: [User]? = nil, errors: [Problem]? = nil, includes: Expansions? = nil, meta: Meta? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
        self.meta = meta
    }
}

public struct Get2TweetsResponse: Codable {
    public var data: [Tweet]?
    public var errors: [Problem]?
    public var includes: Expansions?

    public init(data: [Tweet]? = nil, errors: [Problem]? = nil, includes: Expansions? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
    }
}

public struct Get2TweetsSample10StreamResponse: Codable {
    /// Example:
    ///
    /// {
    ///   "author_id" : "2244994945",
    ///   "created_at" : "Wed Jan 06 18:40:40 +0000 2021",
    ///   "id" : "1346889436626259968",
    ///   "text" : "Learn how to use the user Tweet timeline and user mention timeline endpoints in the Twitter API v2 to explore Tweet\\u2026 https:\\\/\\\/t.co\\\/56a0vZUx7i"
    /// }
    public var data: Tweet?
    public var errors: [Problem]?
    public var includes: Expansions?

    public init(data: Tweet? = nil, errors: [Problem]? = nil, includes: Expansions? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
    }
}

public struct Get2TweetsSampleStreamResponse: Codable {
    /// Example:
    ///
    /// {
    ///   "author_id" : "2244994945",
    ///   "created_at" : "Wed Jan 06 18:40:40 +0000 2021",
    ///   "id" : "1346889436626259968",
    ///   "text" : "Learn how to use the user Tweet timeline and user mention timeline endpoints in the Twitter API v2 to explore Tweet\\u2026 https:\\\/\\\/t.co\\\/56a0vZUx7i"
    /// }
    public var data: Tweet?
    public var errors: [Problem]?
    public var includes: Expansions?

    public init(data: Tweet? = nil, errors: [Problem]? = nil, includes: Expansions? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
    }
}

public struct Get2TweetsSearchAllResponse: Codable {
    public var data: [Tweet]?
    public var errors: [Problem]?
    public var includes: Expansions?
    public var meta: Meta?

    public struct Meta: Codable {
        /// The newest id in this response.
        public var newestID: String?
        /// The next token.
        public var nextToken: String?
        /// The oldest id in this response.
        public var oldestID: String?
        /// The number of results returned in this response.
        public var resultCount: Int?

        public init(newestID: String? = nil, nextToken: String? = nil, oldestID: String? = nil, resultCount: Int? = nil) {
            self.newestID = newestID
            self.nextToken = nextToken
            self.oldestID = oldestID
            self.resultCount = resultCount
        }

        private enum CodingKeys: String, CodingKey {
            case newestID = "newest_id"
            case nextToken = "next_token"
            case oldestID = "oldest_id"
            case resultCount = "result_count"
        }
    }

    public init(data: [Tweet]? = nil, errors: [Problem]? = nil, includes: Expansions? = nil, meta: Meta? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
        self.meta = meta
    }
}

public struct Get2TweetsSearchRecentResponse: Codable {
    public var data: [Tweet]?
    public var errors: [Problem]?
    public var includes: Expansions?
    public var meta: Meta?

    public struct Meta: Codable {
        /// The newest id in this response.
        public var newestID: String?
        /// The next token.
        public var nextToken: String?
        /// The oldest id in this response.
        public var oldestID: String?
        /// The number of results returned in this response.
        public var resultCount: Int?

        public init(newestID: String? = nil, nextToken: String? = nil, oldestID: String? = nil, resultCount: Int? = nil) {
            self.newestID = newestID
            self.nextToken = nextToken
            self.oldestID = oldestID
            self.resultCount = resultCount
        }

        private enum CodingKeys: String, CodingKey {
            case newestID = "newest_id"
            case nextToken = "next_token"
            case oldestID = "oldest_id"
            case resultCount = "result_count"
        }
    }

    public init(data: [Tweet]? = nil, errors: [Problem]? = nil, includes: Expansions? = nil, meta: Meta? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
        self.meta = meta
    }
}

public struct Get2TweetsSearchStreamResponse: Codable {
    /// Example:
    ///
    /// {
    ///   "author_id" : "2244994945",
    ///   "created_at" : "Wed Jan 06 18:40:40 +0000 2021",
    ///   "id" : "1346889436626259968",
    ///   "text" : "Learn how to use the user Tweet timeline and user mention timeline endpoints in the Twitter API v2 to explore Tweet\\u2026 https:\\\/\\\/t.co\\\/56a0vZUx7i"
    /// }
    public var data: Tweet?
    public var errors: [Problem]?
    public var includes: Expansions?

    public init(data: Tweet? = nil, errors: [Problem]? = nil, includes: Expansions? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
    }
}

public struct Get2UsersByResponse: Codable {
    public var data: [User]?
    public var errors: [Problem]?
    public var includes: Expansions?

    public init(data: [User]? = nil, errors: [Problem]? = nil, includes: Expansions? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
    }
}

public struct Get2UsersByUsernameUsernameResponse: Codable {
    /// The Twitter User object.
    ///
    /// Example:
    ///
    /// {
    ///   "created_at" : "2013-12-14T04:35:55Z",
    ///   "id" : "2244994945",
    ///   "name" : "Twitter Dev",
    ///   "protected" : false,
    ///   "username" : "TwitterDev"
    /// }
    public var data: User?
    public var errors: [Problem]?
    public var includes: Expansions?

    public init(data: User? = nil, errors: [Problem]? = nil, includes: Expansions? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
    }
}

public struct Get2UsersIDBlockingResponse: Codable {
    public var data: [User]?
    public var errors: [Problem]?
    public var includes: Expansions?
    public var meta: Meta?

    public struct Meta: Codable {
        /// The next token.
        public var nextToken: String?
        /// The previous token.
        public var previousToken: String?
        /// The number of results returned in this response.
        public var resultCount: Int?

        public init(nextToken: String? = nil, previousToken: String? = nil, resultCount: Int? = nil) {
            self.nextToken = nextToken
            self.previousToken = previousToken
            self.resultCount = resultCount
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "next_token"
            case previousToken = "previous_token"
            case resultCount = "result_count"
        }
    }

    public init(data: [User]? = nil, errors: [Problem]? = nil, includes: Expansions? = nil, meta: Meta? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
        self.meta = meta
    }
}

public struct Get2UsersIDBookmarksResponse: Codable {
    public var data: [Tweet]?
    public var errors: [Problem]?
    public var includes: Expansions?
    public var meta: Meta?

    public struct Meta: Codable {
        /// The next token.
        public var nextToken: String?
        /// The previous token.
        public var previousToken: String?
        /// The number of results returned in this response.
        public var resultCount: Int?

        public init(nextToken: String? = nil, previousToken: String? = nil, resultCount: Int? = nil) {
            self.nextToken = nextToken
            self.previousToken = previousToken
            self.resultCount = resultCount
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "next_token"
            case previousToken = "previous_token"
            case resultCount = "result_count"
        }
    }

    public init(data: [Tweet]? = nil, errors: [Problem]? = nil, includes: Expansions? = nil, meta: Meta? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
        self.meta = meta
    }
}

public struct Get2UsersIDFollowedListsResponse: Codable {
    public var data: [List]?
    public var errors: [Problem]?
    public var includes: Expansions?
    public var meta: Meta?

    public struct Meta: Codable {
        /// The next token.
        public var nextToken: String?
        /// The previous token.
        public var previousToken: String?
        /// The number of results returned in this response.
        public var resultCount: Int?

        public init(nextToken: String? = nil, previousToken: String? = nil, resultCount: Int? = nil) {
            self.nextToken = nextToken
            self.previousToken = previousToken
            self.resultCount = resultCount
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "next_token"
            case previousToken = "previous_token"
            case resultCount = "result_count"
        }
    }

    public init(data: [List]? = nil, errors: [Problem]? = nil, includes: Expansions? = nil, meta: Meta? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
        self.meta = meta
    }
}

public struct Get2UsersIDFollowersResponse: Codable {
    public var data: [User]?
    public var errors: [Problem]?
    public var includes: Expansions?
    public var meta: Meta?

    public struct Meta: Codable {
        /// The next token.
        public var nextToken: String?
        /// The previous token.
        public var previousToken: String?
        /// The number of results returned in this response.
        public var resultCount: Int?

        public init(nextToken: String? = nil, previousToken: String? = nil, resultCount: Int? = nil) {
            self.nextToken = nextToken
            self.previousToken = previousToken
            self.resultCount = resultCount
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "next_token"
            case previousToken = "previous_token"
            case resultCount = "result_count"
        }
    }

    public init(data: [User]? = nil, errors: [Problem]? = nil, includes: Expansions? = nil, meta: Meta? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
        self.meta = meta
    }
}

public struct Get2UsersIDFollowingResponse: Codable {
    public var data: [User]?
    public var errors: [Problem]?
    public var includes: Expansions?
    public var meta: Meta?

    public struct Meta: Codable {
        /// The next token.
        public var nextToken: String?
        /// The previous token.
        public var previousToken: String?
        /// The number of results returned in this response.
        public var resultCount: Int?

        public init(nextToken: String? = nil, previousToken: String? = nil, resultCount: Int? = nil) {
            self.nextToken = nextToken
            self.previousToken = previousToken
            self.resultCount = resultCount
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "next_token"
            case previousToken = "previous_token"
            case resultCount = "result_count"
        }
    }

    public init(data: [User]? = nil, errors: [Problem]? = nil, includes: Expansions? = nil, meta: Meta? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
        self.meta = meta
    }
}

public struct Get2UsersIDLikedTweetsResponse: Codable {
    public var data: [Tweet]?
    public var errors: [Problem]?
    public var includes: Expansions?
    public var meta: Meta?

    public struct Meta: Codable {
        /// The next token.
        public var nextToken: String?
        /// The previous token.
        public var previousToken: String?
        /// The number of results returned in this response.
        public var resultCount: Int?

        public init(nextToken: String? = nil, previousToken: String? = nil, resultCount: Int? = nil) {
            self.nextToken = nextToken
            self.previousToken = previousToken
            self.resultCount = resultCount
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "next_token"
            case previousToken = "previous_token"
            case resultCount = "result_count"
        }
    }

    public init(data: [Tweet]? = nil, errors: [Problem]? = nil, includes: Expansions? = nil, meta: Meta? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
        self.meta = meta
    }
}

public struct Get2UsersIDListMembershipsResponse: Codable {
    public var data: [List]?
    public var errors: [Problem]?
    public var includes: Expansions?
    public var meta: Meta?

    public struct Meta: Codable {
        /// The next token.
        public var nextToken: String?
        /// The previous token.
        public var previousToken: String?
        /// The number of results returned in this response.
        public var resultCount: Int?

        public init(nextToken: String? = nil, previousToken: String? = nil, resultCount: Int? = nil) {
            self.nextToken = nextToken
            self.previousToken = previousToken
            self.resultCount = resultCount
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "next_token"
            case previousToken = "previous_token"
            case resultCount = "result_count"
        }
    }

    public init(data: [List]? = nil, errors: [Problem]? = nil, includes: Expansions? = nil, meta: Meta? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
        self.meta = meta
    }
}

public struct Get2UsersIDMentionsResponse: Codable {
    public var data: [Tweet]?
    public var errors: [Problem]?
    public var includes: Expansions?
    public var meta: Meta?

    public struct Meta: Codable {
        /// The newest id in this response.
        public var newestID: String?
        /// The next token.
        public var nextToken: String?
        /// The oldest id in this response.
        public var oldestID: String?
        /// The previous token.
        public var previousToken: String?
        /// The number of results returned in this response.
        public var resultCount: Int?

        public init(newestID: String? = nil, nextToken: String? = nil, oldestID: String? = nil, previousToken: String? = nil, resultCount: Int? = nil) {
            self.newestID = newestID
            self.nextToken = nextToken
            self.oldestID = oldestID
            self.previousToken = previousToken
            self.resultCount = resultCount
        }

        private enum CodingKeys: String, CodingKey {
            case newestID = "newest_id"
            case nextToken = "next_token"
            case oldestID = "oldest_id"
            case previousToken = "previous_token"
            case resultCount = "result_count"
        }
    }

    public init(data: [Tweet]? = nil, errors: [Problem]? = nil, includes: Expansions? = nil, meta: Meta? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
        self.meta = meta
    }
}

public struct Get2UsersIDMutingResponse: Codable {
    public var data: [User]?
    public var errors: [Problem]?
    public var includes: Expansions?
    public var meta: Meta?

    public struct Meta: Codable {
        /// The next token.
        public var nextToken: String?
        /// The previous token.
        public var previousToken: String?
        /// The number of results returned in this response.
        public var resultCount: Int?

        public init(nextToken: String? = nil, previousToken: String? = nil, resultCount: Int? = nil) {
            self.nextToken = nextToken
            self.previousToken = previousToken
            self.resultCount = resultCount
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "next_token"
            case previousToken = "previous_token"
            case resultCount = "result_count"
        }
    }

    public init(data: [User]? = nil, errors: [Problem]? = nil, includes: Expansions? = nil, meta: Meta? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
        self.meta = meta
    }
}

public struct Get2UsersIDOwnedListsResponse: Codable {
    public var data: [List]?
    public var errors: [Problem]?
    public var includes: Expansions?
    public var meta: Meta?

    public struct Meta: Codable {
        /// The next token.
        public var nextToken: String?
        /// The previous token.
        public var previousToken: String?
        /// The number of results returned in this response.
        public var resultCount: Int?

        public init(nextToken: String? = nil, previousToken: String? = nil, resultCount: Int? = nil) {
            self.nextToken = nextToken
            self.previousToken = previousToken
            self.resultCount = resultCount
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "next_token"
            case previousToken = "previous_token"
            case resultCount = "result_count"
        }
    }

    public init(data: [List]? = nil, errors: [Problem]? = nil, includes: Expansions? = nil, meta: Meta? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
        self.meta = meta
    }
}

public struct Get2UsersIDPinnedListsResponse: Codable {
    public var data: [List]?
    public var errors: [Problem]?
    public var includes: Expansions?
    public var meta: Meta?

    public struct Meta: Codable {
        /// The number of results returned in this response.
        public var resultCount: Int?

        public init(resultCount: Int? = nil) {
            self.resultCount = resultCount
        }

        private enum CodingKeys: String, CodingKey {
            case resultCount = "result_count"
        }
    }

    public init(data: [List]? = nil, errors: [Problem]? = nil, includes: Expansions? = nil, meta: Meta? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
        self.meta = meta
    }
}

public struct Get2UsersIDResponse: Codable {
    /// The Twitter User object.
    ///
    /// Example:
    ///
    /// {
    ///   "created_at" : "2013-12-14T04:35:55Z",
    ///   "id" : "2244994945",
    ///   "name" : "Twitter Dev",
    ///   "protected" : false,
    ///   "username" : "TwitterDev"
    /// }
    public var data: User?
    public var errors: [Problem]?
    public var includes: Expansions?

    public init(data: User? = nil, errors: [Problem]? = nil, includes: Expansions? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
    }
}

public struct Get2UsersIDTimelinesReverseChronologicalResponse: Codable {
    public var data: [Tweet]?
    public var errors: [Problem]?
    public var includes: Expansions?
    public var meta: Meta?

    public struct Meta: Codable {
        /// The newest id in this response.
        public var newestID: String?
        /// The next token.
        public var nextToken: String?
        /// The oldest id in this response.
        public var oldestID: String?
        /// The previous token.
        public var previousToken: String?
        /// The number of results returned in this response.
        public var resultCount: Int?

        public init(newestID: String? = nil, nextToken: String? = nil, oldestID: String? = nil, previousToken: String? = nil, resultCount: Int? = nil) {
            self.newestID = newestID
            self.nextToken = nextToken
            self.oldestID = oldestID
            self.previousToken = previousToken
            self.resultCount = resultCount
        }

        private enum CodingKeys: String, CodingKey {
            case newestID = "newest_id"
            case nextToken = "next_token"
            case oldestID = "oldest_id"
            case previousToken = "previous_token"
            case resultCount = "result_count"
        }
    }

    public init(data: [Tweet]? = nil, errors: [Problem]? = nil, includes: Expansions? = nil, meta: Meta? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
        self.meta = meta
    }
}

public struct Get2UsersIDTweetsResponse: Codable {
    public var data: [Tweet]?
    public var errors: [Problem]?
    public var includes: Expansions?
    public var meta: Meta?

    public struct Meta: Codable {
        /// The newest id in this response.
        public var newestID: String?
        /// The next token.
        public var nextToken: String?
        /// The oldest id in this response.
        public var oldestID: String?
        /// The previous token.
        public var previousToken: String?
        /// The number of results returned in this response.
        public var resultCount: Int?

        public init(newestID: String? = nil, nextToken: String? = nil, oldestID: String? = nil, previousToken: String? = nil, resultCount: Int? = nil) {
            self.newestID = newestID
            self.nextToken = nextToken
            self.oldestID = oldestID
            self.previousToken = previousToken
            self.resultCount = resultCount
        }

        private enum CodingKeys: String, CodingKey {
            case newestID = "newest_id"
            case nextToken = "next_token"
            case oldestID = "oldest_id"
            case previousToken = "previous_token"
            case resultCount = "result_count"
        }
    }

    public init(data: [Tweet]? = nil, errors: [Problem]? = nil, includes: Expansions? = nil, meta: Meta? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
        self.meta = meta
    }
}

public struct Get2UsersMeResponse: Codable {
    /// The Twitter User object.
    ///
    /// Example:
    ///
    /// {
    ///   "created_at" : "2013-12-14T04:35:55Z",
    ///   "id" : "2244994945",
    ///   "name" : "Twitter Dev",
    ///   "protected" : false,
    ///   "username" : "TwitterDev"
    /// }
    public var data: User?
    public var errors: [Problem]?
    public var includes: Expansions?

    public init(data: User? = nil, errors: [Problem]? = nil, includes: Expansions? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
    }
}

public struct Get2UsersResponse: Codable {
    public var data: [User]?
    public var errors: [Problem]?
    public var includes: Expansions?

    public init(data: [User]? = nil, errors: [Problem]? = nil, includes: Expansions? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
    }
}

public struct HashtagEntity: Codable {
    /// Represent a boundary range (start and end index) for a recognized entity (for example a hashtag or a mention). `start` must be smaller than `end`.  The start index is inclusive, the end index is exclusive.
    public var entityIndicesInclusiveExclusive: EntityIndicesInclusiveExclusive
    /// Represent the portion of text recognized as a Hashtag, and its start and end position within the text.
    public var hashtagFields: HashtagFields

    public init(entityIndicesInclusiveExclusive: EntityIndicesInclusiveExclusive, hashtagFields: HashtagFields) {
        self.entityIndicesInclusiveExclusive = entityIndicesInclusiveExclusive
        self.hashtagFields = hashtagFields
    }

    public init(from decoder: Decoder) throws {
        self.entityIndicesInclusiveExclusive = try EntityIndicesInclusiveExclusive(from: decoder)
        self.hashtagFields = try HashtagFields(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(entityIndicesInclusiveExclusive, forKey: "entityIndicesInclusiveExclusive")
        try values.encode(hashtagFields, forKey: "hashtagFields")
    }
}

/// Represent the portion of text recognized as a Hashtag, and its start and end position within the text.
public struct HashtagFields: Codable {
    /// The text of the Hashtag.
    ///
    /// Example: "MondayMotivation"
    public var tag: String

    public init(tag: String) {
        self.tag = tag
    }
}

/// A problem that indicates this request is invalid.
public struct InvalidRequestProblem: Codable {
    /// An HTTP Problem Details object, as defined in IETF RFC 7807 (https://tools.ietf.org/html/rfc7807).
    public var problem: Problem
    public var errors: [Error]?

    public struct Error: Codable {
        public var message: String?
        public var parameters: [String: [String]]?

        public init(message: String? = nil, parameters: [String: [String]]? = nil) {
            self.message = message
            self.parameters = parameters
        }
    }

    public init(problem: Problem, errors: [Error]? = nil) {
        self.problem = problem
        self.errors = errors
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.problem = try Problem(from: decoder)
        self.errors = try values.decodeIfPresent([Error].self, forKey: "errors")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(problem, forKey: "problem")
        try values.encodeIfPresent(errors, forKey: "errors")
    }
}

/// A Twitter List is a curated group of accounts.
public struct List: Codable {
    public var createdAt: Date?
    public var description: String?
    public var followerCount: Int?
    /// The unique identifier of this List.
    ///
    /// Example: "1146654567674912769"
    public var id: String
    public var memberCount: Int?
    /// The name of this List.
    public var name: String
    /// Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
    ///
    /// Example: "2244994945"
    public var ownerID: String?
    public var isPrivate: Bool?

    public init(createdAt: Date? = nil, description: String? = nil, followerCount: Int? = nil, id: String, memberCount: Int? = nil, name: String, ownerID: String? = nil, isPrivate: Bool? = nil) {
        self.createdAt = createdAt
        self.description = description
        self.followerCount = followerCount
        self.id = id
        self.memberCount = memberCount
        self.name = name
        self.ownerID = ownerID
        self.isPrivate = isPrivate
    }

    private enum CodingKeys: String, CodingKey {
        case createdAt = "created_at"
        case description
        case followerCount = "follower_count"
        case id
        case memberCount = "member_count"
        case name
        case ownerID = "owner_id"
        case isPrivate = "private"
    }
}

public struct ListAddUserRequest: Codable {
    /// Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
    ///
    /// Example: "2244994945"
    public var userID: String

    public init(userID: String) {
        self.userID = userID
    }

    private enum CodingKeys: String, CodingKey {
        case userID = "user_id"
    }
}

public struct ListCreateRequest: Codable {
    public var description: String?
    public var name: String
    public var isPrivate: Bool

    public init(description: String? = nil, name: String, isPrivate: Bool? = nil) {
        self.description = description
        self.name = name
        self.isPrivate = isPrivate ?? false
    }

    private enum CodingKeys: String, CodingKey {
        case description
        case name
        case isPrivate = "private"
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.description = try values.decodeIfPresent(String.self, forKey: .description)
        self.name = try values.decode(String.self, forKey: .name)
        self.isPrivate = try values.decodeIfPresent(Bool.self, forKey: .isPrivate) ?? false
    }
}

public struct ListCreateResponse: Codable {
    /// A Twitter List is a curated group of accounts.
    public var data: Data?
    public var errors: [Problem]?

    /// A Twitter List is a curated group of accounts.
    public struct Data: Codable {
        /// The unique identifier of this List.
        ///
        /// Example: "1146654567674912769"
        public var id: String
        /// The name of this List.
        public var name: String

        public init(id: String, name: String) {
            self.id = id
            self.name = name
        }
    }

    public init(data: Data? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

public struct ListDeleteResponse: Codable {
    public var data: Data?
    public var errors: [Problem]?

    public struct Data: Codable {
        public var isDeleted: Bool?

        public init(isDeleted: Bool? = nil) {
            self.isDeleted = isDeleted
        }

        private enum CodingKeys: String, CodingKey {
            case isDeleted = "deleted"
        }
    }

    public init(data: Data? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

public struct ListFollowedRequest: Codable {
    /// The unique identifier of this List.
    ///
    /// Example: "1146654567674912769"
    public var listID: String

    public init(listID: String) {
        self.listID = listID
    }

    private enum CodingKeys: String, CodingKey {
        case listID = "list_id"
    }
}

public struct ListFollowedResponse: Codable {
    public var data: Data?
    public var errors: [Problem]?

    public struct Data: Codable {
        public var isFollowing: Bool?

        public init(isFollowing: Bool? = nil) {
            self.isFollowing = isFollowing
        }

        private enum CodingKeys: String, CodingKey {
            case isFollowing = "following"
        }
    }

    public init(data: Data? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

public struct ListMutateResponse: Codable {
    public var data: Data?
    public var errors: [Problem]?

    public struct Data: Codable {
        public var isMember: Bool?

        public init(isMember: Bool? = nil) {
            self.isMember = isMember
        }

        private enum CodingKeys: String, CodingKey {
            case isMember = "is_member"
        }
    }

    public init(data: Data? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

public struct ListPinnedRequest: Codable {
    /// The unique identifier of this List.
    ///
    /// Example: "1146654567674912769"
    public var listID: String

    public init(listID: String) {
        self.listID = listID
    }

    private enum CodingKeys: String, CodingKey {
        case listID = "list_id"
    }
}

public struct ListPinnedResponse: Codable {
    public var data: Data?
    public var errors: [Problem]?

    public struct Data: Codable {
        public var isPinned: Bool?

        public init(isPinned: Bool? = nil) {
            self.isPinned = isPinned
        }

        private enum CodingKeys: String, CodingKey {
            case isPinned = "pinned"
        }
    }

    public init(data: Data? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

public struct ListUnpinResponse: Codable {
    public var data: Data?
    public var errors: [Problem]?

    public struct Data: Codable {
        public var isPinned: Bool?

        public init(isPinned: Bool? = nil) {
            self.isPinned = isPinned
        }

        private enum CodingKeys: String, CodingKey {
            case isPinned = "pinned"
        }
    }

    public init(data: Data? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

public struct ListUpdateRequest: Codable {
    public var description: String?
    public var name: String?
    public var isPrivate: Bool?

    public init(description: String? = nil, name: String? = nil, isPrivate: Bool? = nil) {
        self.description = description
        self.name = name
        self.isPrivate = isPrivate
    }

    private enum CodingKeys: String, CodingKey {
        case description
        case name
        case isPrivate = "private"
    }
}

public struct ListUpdateResponse: Codable {
    public var data: Data?
    public var errors: [Problem]?

    public struct Data: Codable {
        public var isUpdated: Bool?

        public init(isUpdated: Bool? = nil) {
            self.isUpdated = isUpdated
        }

        private enum CodingKeys: String, CodingKey {
            case isUpdated = "updated"
        }
    }

    public init(data: Data? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

public struct Media: Codable {
    /// The height of the media in pixels.
    public var height: Int?
    /// The Media Key identifier for this attachment.
    public var mediaKey: String?
    public var type: String
    /// The width of the media in pixels.
    public var width: Int?

    public init(height: Int? = nil, mediaKey: String? = nil, type: String, width: Int? = nil) {
        self.height = height
        self.mediaKey = mediaKey
        self.type = type
        self.width = width
    }

    private enum CodingKeys: String, CodingKey {
        case height
        case mediaKey = "media_key"
        case type
        case width
    }
}

public struct MentionEntity: Codable {
    /// Represent a boundary range (start and end index) for a recognized entity (for example a hashtag or a mention). `start` must be smaller than `end`.  The start index is inclusive, the end index is exclusive.
    public var entityIndicesInclusiveExclusive: EntityIndicesInclusiveExclusive
    /// Represent the portion of text recognized as a User mention, and its start and end position within the text.
    public var mentionFields: MentionFields

    public init(entityIndicesInclusiveExclusive: EntityIndicesInclusiveExclusive, mentionFields: MentionFields) {
        self.entityIndicesInclusiveExclusive = entityIndicesInclusiveExclusive
        self.mentionFields = mentionFields
    }

    public init(from decoder: Decoder) throws {
        self.entityIndicesInclusiveExclusive = try EntityIndicesInclusiveExclusive(from: decoder)
        self.mentionFields = try MentionFields(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(entityIndicesInclusiveExclusive, forKey: "entityIndicesInclusiveExclusive")
        try values.encode(mentionFields, forKey: "mentionFields")
    }
}

/// Represent the portion of text recognized as a User mention, and its start and end position within the text.
public struct MentionFields: Codable {
    /// Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
    ///
    /// Example: "2244994945"
    public var id: String?
    /// The Twitter handle (screen name) of this user.
    public var username: String

    public init(id: String? = nil, username: String) {
        self.id = id
        self.username = username
    }
}

public struct MuteUserMutationResponse: Codable {
    public var data: Data?
    public var errors: [Problem]?

    public struct Data: Codable {
        public var isMuting: Bool?

        public init(isMuting: Bool? = nil) {
            self.isMuting = isMuting
        }

        private enum CodingKeys: String, CodingKey {
            case isMuting = "muting"
        }
    }

    public init(data: Data? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

public struct MuteUserRequest: Codable {
    /// Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
    ///
    /// Example: "2244994945"
    public var targetUserID: String

    public init(targetUserID: String) {
        self.targetUserID = targetUserID
    }

    private enum CodingKeys: String, CodingKey {
        case targetUserID = "target_user_id"
    }
}

/// You have been disconnected for operational reasons.
public struct OperationalDisconnectProblem: Codable {
    /// An HTTP Problem Details object, as defined in IETF RFC 7807 (https://tools.ietf.org/html/rfc7807).
    public var problem: Problem
    public var disconnectType: DisconnectType?

    public enum DisconnectType: String, Codable, CaseIterable {
        case operationalDisconnect = "OperationalDisconnect"
        case upstreamOperationalDisconnect = "UpstreamOperationalDisconnect"
        case forceDisconnect = "ForceDisconnect"
        case upstreamUncleanDisconnect = "UpstreamUncleanDisconnect"
        case slowReader = "SlowReader"
        case internalError = "InternalError"
        case clientApplicationStateDegraded = "ClientApplicationStateDegraded"
        case invalidRules = "InvalidRules"
    }

    public init(problem: Problem, disconnectType: DisconnectType? = nil) {
        self.problem = problem
        self.disconnectType = disconnectType
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.problem = try Problem(from: decoder)
        self.disconnectType = try values.decodeIfPresent(DisconnectType.self, forKey: "disconnect_type")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(problem, forKey: "problem")
        try values.encodeIfPresent(disconnectType, forKey: "disconnect_type")
    }
}

public struct Photo: Codable {
    public var media: Media
    public var altText: String?
    public var url: URL?

    public init(media: Media, altText: String? = nil, url: URL? = nil) {
        self.media = media
        self.altText = altText
        self.url = url
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.media = try Media(from: decoder)
        self.altText = try values.decodeIfPresent(String.self, forKey: "alt_text")
        self.url = try values.decodeIfPresent(URL.self, forKey: "url")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(media, forKey: "media")
        try values.encodeIfPresent(altText, forKey: "alt_text")
        try values.encodeIfPresent(url, forKey: "url")
    }
}

public struct Place: Codable {
    public var containedWithin: [String]?
    /// The full name of the county in which this place exists.
    ///
    /// Example: "United States"
    public var country: String?
    /// A two-letter ISO 3166-1 alpha-2 country code.
    ///
    /// Example: "US"
    public var countryCode: String?
    /// The full name of this place.
    ///
    /// Example: "Lakewood, CO"
    public var fullName: String
    public var geo: Geo?
    /// The identifier for this place.
    ///
    /// Example: "f7eb2fa2fea288b1"
    public var id: String
    /// The human readable name of this place.
    ///
    /// Example: "Lakewood"
    public var name: String?
    /// Example: "city"
    public var placeType: PlaceType?

    public init(containedWithin: [String]? = nil, country: String? = nil, countryCode: String? = nil, fullName: String, geo: Geo? = nil, id: String, name: String? = nil, placeType: PlaceType? = nil) {
        self.containedWithin = containedWithin
        self.country = country
        self.countryCode = countryCode
        self.fullName = fullName
        self.geo = geo
        self.id = id
        self.name = name
        self.placeType = placeType
    }

    private enum CodingKeys: String, CodingKey {
        case containedWithin = "contained_within"
        case country
        case countryCode = "country_code"
        case fullName = "full_name"
        case geo
        case id
        case name
        case placeType = "place_type"
    }
}

/// Example: "city"
public enum PlaceType: String, Codable, CaseIterable {
    case poi
    case neighborhood
    case city
    case admin
    case country
    case unknown
}

/// A [GeoJson Point](https://tools.ietf.org/html/rfc7946#section-3.1.2) geometry object.
public struct Point: Codable {
    /// A [GeoJson Position](https://tools.ietf.org/html/rfc7946#section-3.1.1) in the format `[longitude,latitude]`.
    ///
    /// Example:
    ///
    /// [
    ///   -105.18816086351444,
    ///   40.247749999999996
    /// ]
    public var coordinates: [Double]
    /// Example: "Point"
    public var type: `Type`

    /// Example: "Point"
    public enum `Type`: String, Codable, CaseIterable {
        case point = "Point"
    }

    public init(coordinates: [Double], type: `Type`) {
        self.coordinates = coordinates
        self.type = type
    }
}

/// Represent a Poll attached to a Tweet.
public struct Poll: Codable {
    public var durationMinutes: Int?
    public var endDatetime: Date?
    /// Unique identifier of this poll.
    ///
    /// Example: "1365059861688410112"
    public var id: String
    public var options: [PollOption]
    public var votingStatus: VotingStatus?

    public enum VotingStatus: String, Codable, CaseIterable {
        case `open`
        case closed
    }

    public init(durationMinutes: Int? = nil, endDatetime: Date? = nil, id: String, options: [PollOption], votingStatus: VotingStatus? = nil) {
        self.durationMinutes = durationMinutes
        self.endDatetime = endDatetime
        self.id = id
        self.options = options
        self.votingStatus = votingStatus
    }

    private enum CodingKeys: String, CodingKey {
        case durationMinutes = "duration_minutes"
        case endDatetime = "end_datetime"
        case id
        case options
        case votingStatus = "voting_status"
    }
}

/// Describes a choice in a Poll object.
public struct PollOption: Codable {
    /// The text of a poll choice.
    public var label: String
    /// Position of this choice in the poll.
    public var position: Int
    /// Number of users who voted for this choice.
    public var votes: Int

    public init(label: String, position: Int, votes: Int) {
        self.label = label
        self.position = position
        self.votes = votes
    }
}

/// An HTTP Problem Details object, as defined in IETF RFC 7807 (https://tools.ietf.org/html/rfc7807).
public struct Problem: Codable {
    public var detail: String?
    public var status: Int?
    public var title: String
    public var type: String

    public init(detail: String? = nil, status: Int? = nil, title: String, type: String) {
        self.detail = detail
        self.status = status
        self.title = title
        self.type = type
    }
}

public struct ProblemErrors: Codable {
    public var errors: [Problem]

    public init(errors: [Problem]) {
        self.errors = errors
    }
}

/// Represents the response in case of throwing an exception. Mainly for the openapi-generator
public enum ProblemOrError: Codable {
    case error(Error)
    case problem(Problem)

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let value = try? container.decode(Error.self) {
            self = .error(value)
        } else if let value = try? container.decode(Problem.self) {
            self = .problem(value)
        } else {
            throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .error(let value): try container.encode(value)
        case .problem(let value): try container.encode(value)
        }
    }
}

/// Shows who can reply a Tweet. Fields returned are everyone, mentioned_users, and following.
public enum ReplySettings: String, Codable, CaseIterable {
    case everyone
    case mentionedUsers
    case following
    case other
}

public struct ReportUsersRequest: Codable {
    public var description: String
    public var userIDs: [String]

    public init(description: String, userIDs: [String]) {
        self.description = description
        self.userIDs = userIDs
    }

    private enum CodingKeys: String, CodingKey {
        case description
        case userIDs = "user_ids"
    }
}

public struct ReportUsersResponse: Codable {
    public var data: Data?

    public struct Data: Codable {
        public var id: Int?

        public init(id: Int? = nil) {
            self.id = id
        }
    }

    public init(data: Data? = nil) {
        self.data = data
    }
}

/// A problem that indicates that a given Tweet, User, etc. does not exist.
public struct ResourceNotFoundProblem: Codable {
    /// An HTTP Problem Details object, as defined in IETF RFC 7807 (https://tools.ietf.org/html/rfc7807).
    public var problem: Problem
    public var parameter: String
    public var resourceID: String
    public var resourceType: ResourceType
    /// Value will match the schema of the field.
    public var value: String

    public enum ResourceType: String, Codable, CaseIterable {
        case user
        case tweet
        case media
        case list
        case space
    }

    public init(problem: Problem, parameter: String, resourceID: String, resourceType: ResourceType, value: String) {
        self.problem = problem
        self.parameter = parameter
        self.resourceID = resourceID
        self.resourceType = resourceType
        self.value = value
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.problem = try Problem(from: decoder)
        self.parameter = try values.decode(String.self, forKey: "parameter")
        self.resourceID = try values.decode(String.self, forKey: "resource_id")
        self.resourceType = try values.decode(ResourceType.self, forKey: "resource_type")
        self.value = try values.decode(String.self, forKey: "value")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(problem, forKey: "problem")
        try values.encode(parameter, forKey: "parameter")
        try values.encode(resourceID, forKey: "resource_id")
        try values.encode(resourceType, forKey: "resource_type")
        try values.encode(value, forKey: "value")
    }
}

/// A problem that indicates you are not allowed to see a particular Tweet, User, etc.
public struct ResourceUnauthorizedProblem: Codable {
    /// An HTTP Problem Details object, as defined in IETF RFC 7807 (https://tools.ietf.org/html/rfc7807).
    public var problem: Problem
    public var parameter: String
    public var resourceID: String
    public var resourceType: ResourceType
    public var section: Section
    public var value: String

    public enum ResourceType: String, Codable, CaseIterable {
        case user
        case tweet
        case media
        case list
        case space
    }

    public enum Section: String, Codable, CaseIterable {
        case data
        case includes
    }

    public init(problem: Problem, parameter: String, resourceID: String, resourceType: ResourceType, section: Section, value: String) {
        self.problem = problem
        self.parameter = parameter
        self.resourceID = resourceID
        self.resourceType = resourceType
        self.section = section
        self.value = value
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.problem = try Problem(from: decoder)
        self.parameter = try values.decode(String.self, forKey: "parameter")
        self.resourceID = try values.decode(String.self, forKey: "resource_id")
        self.resourceType = try values.decode(ResourceType.self, forKey: "resource_type")
        self.section = try values.decode(Section.self, forKey: "section")
        self.value = try values.decode(String.self, forKey: "value")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(problem, forKey: "problem")
        try values.encode(parameter, forKey: "parameter")
        try values.encode(resourceID, forKey: "resource_id")
        try values.encode(resourceType, forKey: "resource_type")
        try values.encode(section, forKey: "section")
        try values.encode(value, forKey: "value")
    }
}

/// A problem that indicates a particular Tweet, User, etc. is not available to you.
public struct ResourceUnavailableProblem: Codable {
    /// An HTTP Problem Details object, as defined in IETF RFC 7807 (https://tools.ietf.org/html/rfc7807).
    public var problem: Problem
    public var parameter: String
    public var resourceID: String
    public var resourceType: ResourceType

    public enum ResourceType: String, Codable, CaseIterable {
        case user
        case tweet
        case media
        case list
        case space
    }

    public init(problem: Problem, parameter: String, resourceID: String, resourceType: ResourceType) {
        self.problem = problem
        self.parameter = parameter
        self.resourceID = resourceID
        self.resourceType = resourceType
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.problem = try Problem(from: decoder)
        self.parameter = try values.decode(String.self, forKey: "parameter")
        self.resourceID = try values.decode(String.self, forKey: "resource_id")
        self.resourceType = try values.decode(ResourceType.self, forKey: "resource_type")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(problem, forKey: "problem")
        try values.encode(parameter, forKey: "parameter")
        try values.encode(resourceID, forKey: "resource_id")
        try values.encode(resourceType, forKey: "resource_type")
    }
}

/// A user-provided stream filtering rule.
public struct Rule: Codable {
    /// Unique identifier of this rule.
    ///
    /// Example: "120897978112909812"
    public var id: String?
    /// A tag meant for the labeling of user provided rules.
    ///
    /// Example: "Non-retweeted coffee Tweets"
    public var tag: String?
    /// The filterlang value of the rule.
    ///
    /// Example: "coffee -is:retweet"
    public var value: String

    public init(id: String? = nil, tag: String? = nil, value: String) {
        self.id = id
        self.tag = tag
        self.value = value
    }
}

/// A user-provided stream filtering rule.
public struct RuleNoID: Codable {
    /// A tag meant for the labeling of user provided rules.
    ///
    /// Example: "Non-retweeted coffee Tweets"
    public var tag: String?
    /// The filterlang value of the rule.
    ///
    /// Example: "coffee -is:retweet"
    public var value: String

    public init(tag: String? = nil, value: String) {
        self.tag = tag
        self.value = value
    }
}

public struct RulesLookupResponse: Codable {
    public var data: [Rule]
    public var meta: RulesResponseMetadata

    public init(data: [Rule], meta: RulesResponseMetadata) {
        self.data = data
        self.meta = meta
    }
}

public enum RulesRequestSummary: Codable {
    case a(A)
    case b(B)

    /// A summary of the results of the addition of user-specified stream filtering rules.
    public struct A: Codable {
        /// Number of user-specified stream filtering rules that were created.
        public var created: Int
        /// Number of invalid user-specified stream filtering rules.
        public var invalid: Int
        /// Number of user-specified stream filtering rules that were not created.
        public var notCreated: Int
        /// Number of valid user-specified stream filtering rules.
        public var valid: Int

        public init(created: Int, invalid: Int, notCreated: Int, valid: Int) {
            self.created = created
            self.invalid = invalid
            self.notCreated = notCreated
            self.valid = valid
        }

        private enum CodingKeys: String, CodingKey {
            case created
            case invalid
            case notCreated = "not_created"
            case valid
        }
    }

    public struct B: Codable {
        /// Number of user-specified stream filtering rules that were deleted.
        public var deleted: Int
        /// Number of user-specified stream filtering rules that were not deleted.
        public var notDeleted: Int

        public init(deleted: Int, notDeleted: Int) {
            self.deleted = deleted
            self.notDeleted = notDeleted
        }

        private enum CodingKeys: String, CodingKey {
            case deleted
            case notDeleted = "not_deleted"
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let value = try? container.decode(A.self) {
            self = .a(value)
        } else if let value = try? container.decode(B.self) {
            self = .b(value)
        } else {
            throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .a(let value): try container.encode(value)
        case .b(let value): try container.encode(value)
        }
    }
}

public struct RulesResponseMetadata: Codable {
    /// The next token.
    public var nextToken: String?
    /// Number of Rules in result set.
    public var resultCount: Int?
    public var sent: String
    public var summary: RulesRequestSummary?

    public init(nextToken: String? = nil, resultCount: Int? = nil, sent: String, summary: RulesRequestSummary? = nil) {
        self.nextToken = nextToken
        self.resultCount = resultCount
        self.sent = sent
        self.summary = summary
    }

    private enum CodingKeys: String, CodingKey {
        case nextToken = "next_token"
        case resultCount = "result_count"
        case sent
        case summary
    }
}

/// Represent a Search Count Result.
public struct SearchCount: Codable {
    /// The end time of the bucket.
    public var end: Date
    /// The start time of the bucket.
    public var start: Date
    /// The count for the bucket.
    public var tweetCount: Int

    public init(end: Date, start: Date, tweetCount: Int) {
        self.end = end
        self.start = start
        self.tweetCount = tweetCount
    }

    private enum CodingKeys: String, CodingKey {
        case end
        case start
        case tweetCount = "tweet_count"
    }
}

public struct Space: Codable {
    /// Creation time of the Space.
    ///
    /// Example: "2021-07-06T18:40:40.000Z"
    public var createdAt: Date?
    /// Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
    ///
    /// Example: "2244994945"
    public var creatorID: String?
    /// End time of the Space.
    ///
    /// Example: "2021-07-06T18:40:40.000Z"
    public var endedAt: Date?
    /// The user ids for the hosts of the Space.
    public var hostIDs: [String]?
    /// The unique identifier of this Space.
    ///
    /// Example: "1SLjjRYNejbKM"
    public var id: String
    /// An array of user ids for people who were invited to a Space.
    public var invitedUserIDs: [String]?
    /// Denotes if the Space is a ticketed Space.
    ///
    /// Example: false
    public var isTicketed: Bool?
    /// The language of the Space.
    ///
    /// Example: "en"
    public var lang: String?
    /// The number of participants in a Space.
    ///
    /// Example: 10
    public var participantCount: Int?
    /// A date time stamp for when a Space is scheduled to begin.
    ///
    /// Example: "2021-07-06T18:40:40.000Z"
    public var scheduledStart: Date?
    /// An array of user ids for people who were speakers in a Space.
    public var speakerIDs: [String]?
    /// When the Space was started as a date string.
    ///
    /// Example: "2021-7-14T04:35:55Z"
    public var startedAt: Date?
    /// The current state of the Space.
    ///
    /// Example: "live"
    public var state: State
    /// The number of people who have either purchased a ticket or set a reminder for this Space.
    ///
    /// Example: 10
    public var subscriberCount: Int?
    /// The title of the Space.
    ///
    /// Example: "Spaces are Awesome"
    public var title: String?
    /// The topics of a Space, as selected by its creator.
    public var topics: [Topic]?
    /// When the Space was last updated.
    ///
    /// Example: "2021-7-14T04:35:55Z"
    public var updatedAt: Date?

    /// The current state of the Space.
    ///
    /// Example: "live"
    public enum State: String, Codable, CaseIterable {
        case live
        case scheduled
        case ended
    }

    /// The Twitter Topic object.
    ///
    /// Example:
    ///
    /// {
    ///   "description" : "All about technology",
    ///   "id" : "848920371311001600",
    ///   "name" : "Technology"
    /// }
    public struct Topic: Codable {
        /// The description of the given topic.
        public var description: String?
        /// An ID suitable for use in the REST API.
        public var id: String
        /// The name of the given topic.
        public var name: String

        public init(description: String? = nil, id: String, name: String) {
            self.description = description
            self.id = id
            self.name = name
        }
    }

    public init(createdAt: Date? = nil, creatorID: String? = nil, endedAt: Date? = nil, hostIDs: [String]? = nil, id: String, invitedUserIDs: [String]? = nil, isTicketed: Bool? = nil, lang: String? = nil, participantCount: Int? = nil, scheduledStart: Date? = nil, speakerIDs: [String]? = nil, startedAt: Date? = nil, state: State, subscriberCount: Int? = nil, title: String? = nil, topics: [Topic]? = nil, updatedAt: Date? = nil) {
        self.createdAt = createdAt
        self.creatorID = creatorID
        self.endedAt = endedAt
        self.hostIDs = hostIDs
        self.id = id
        self.invitedUserIDs = invitedUserIDs
        self.isTicketed = isTicketed
        self.lang = lang
        self.participantCount = participantCount
        self.scheduledStart = scheduledStart
        self.speakerIDs = speakerIDs
        self.startedAt = startedAt
        self.state = state
        self.subscriberCount = subscriberCount
        self.title = title
        self.topics = topics
        self.updatedAt = updatedAt
    }

    private enum CodingKeys: String, CodingKey {
        case createdAt = "created_at"
        case creatorID = "creator_id"
        case endedAt = "ended_at"
        case hostIDs = "host_ids"
        case id
        case invitedUserIDs = "invited_user_ids"
        case isTicketed = "is_ticketed"
        case lang
        case participantCount = "participant_count"
        case scheduledStart = "scheduled_start"
        case speakerIDs = "speaker_ids"
        case startedAt = "started_at"
        case state
        case subscriberCount = "subscriber_count"
        case title
        case topics
        case updatedAt = "updated_at"
    }
}

public struct StreamingTweetResponse: Codable {
    /// Example:
    ///
    /// {
    ///   "author_id" : "2244994945",
    ///   "created_at" : "Wed Jan 06 18:40:40 +0000 2021",
    ///   "id" : "1346889436626259968",
    ///   "text" : "Learn how to use the user Tweet timeline and user mention timeline endpoints in the Twitter API v2 to explore Tweet\\u2026 https:\\\/\\\/t.co\\\/56a0vZUx7i"
    /// }
    public var data: Tweet?
    public var errors: [Problem]?
    public var includes: Expansions?

    public init(data: Tweet? = nil, errors: [Problem]? = nil, includes: Expansions? = nil) {
        self.data = data
        self.errors = errors
        self.includes = includes
    }
}

/// The topic of a Space, as selected by its creator.
public struct Topic: Codable {
    /// The description of the given topic.
    ///
    /// Example: "All about technology"
    public var description: String?
    /// Unique identifier of this Topic.
    public var id: String
    /// The name of the given topic.
    ///
    /// Example: "Technology"
    public var name: String

    public init(description: String? = nil, id: String, name: String) {
        self.description = description
        self.id = id
        self.name = name
    }
}

/// Example:
///
/// {
///   "author_id" : "2244994945",
///   "created_at" : "Wed Jan 06 18:40:40 +0000 2021",
///   "id" : "1346889436626259968",
///   "text" : "Learn how to use the user Tweet timeline and user mention timeline endpoints in the Twitter API v2 to explore Tweet\\u2026 https:\\\/\\\/t.co\\\/56a0vZUx7i"
/// }
public struct Tweet: Codable {
    /// Specifies the type of attachments (if any) present in this Tweet.
    public var attachments: Attachments?
    /// Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
    ///
    /// Example: "2244994945"
    public var authorID: String?
    public var contextAnnotations: [ContextAnnotation]?
    /// Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
    ///
    /// Example: "1346889436626259968"
    public var conversationID: String?
    /// Creation time of the Tweet.
    ///
    /// Example: "2021-01-06T18:40:40.000Z"
    public var createdAt: Date?
    public var entities: FullTextEntities?
    /// The location tagged on the Tweet, if the user provided one.
    public var geo: Geo?
    /// Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
    ///
    /// Example: "1346889436626259968"
    public var id: String
    /// Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
    ///
    /// Example: "2244994945"
    public var inReplyToUserID: String?
    /// Language of the Tweet, if detected by Twitter. Returned as a BCP47 language tag.
    ///
    /// Example: "en"
    public var lang: String?
    /// Nonpublic engagement metrics for the Tweet at the time of the request.
    public var nonPublicMetrics: NonPublicMetrics?
    /// Organic nonpublic engagement metrics for the Tweet at the time of the request.
    public var organicMetrics: OrganicMetrics?
    /// Indicates if this Tweet contains URLs marked as sensitive, for example content suitable for mature audiences.
    ///
    /// Example: false
    public var isPossiblySensitive: Bool?
    /// Promoted nonpublic engagement metrics for the Tweet at the time of the request.
    public var promotedMetrics: PromotedMetrics?
    /// Engagement metrics for the Tweet at the time of the request.
    public var publicMetrics: PublicMetrics?
    /// A list of Tweets this Tweet refers to. For example, if the parent Tweet is a Retweet, a Quoted Tweet or a Reply, it will include the related Tweet referenced to by its parent.
    public var referencedTweets: [ReferencedTweet]?
    /// Shows who can reply a Tweet. Fields returned are everyone, mentioned_users, and following.
    public var replySettings: ReplySettings?
    /// The name of the app the user Tweeted from.
    public var source: String?
    /// The content of the Tweet.
    ///
    /// Example: "Learn how to use the user Tweet timeline and user mention timeline endpoints in the Twitter API v2 to explore Tweet\u2026 https:\/\/t.co\/56a0vZUx7i"
    public var text: String
    /// Indicates withholding details for [withheld content](https://help.twitter.com/en/rules-and-policies/tweet-withheld-by-country).
    public var withheld: TweetWithheld?

    /// Specifies the type of attachments (if any) present in this Tweet.
    public struct Attachments: Codable {
        /// A list of Media Keys for each one of the media attachments (if media are attached).
        public var mediaKeys: [String]?
        /// A list of poll IDs (if polls are attached).
        public var pollIDs: [String]?

        public init(mediaKeys: [String]? = nil, pollIDs: [String]? = nil) {
            self.mediaKeys = mediaKeys
            self.pollIDs = pollIDs
        }

        private enum CodingKeys: String, CodingKey {
            case mediaKeys = "media_keys"
            case pollIDs = "poll_ids"
        }
    }

    /// The location tagged on the Tweet, if the user provided one.
    public struct Geo: Codable {
        /// A [GeoJson Point](https://tools.ietf.org/html/rfc7946#section-3.1.2) geometry object.
        public var coordinates: Point?
        /// The identifier for this place.
        ///
        /// Example: "f7eb2fa2fea288b1"
        public var placeID: String?

        public init(coordinates: Point? = nil, placeID: String? = nil) {
            self.coordinates = coordinates
            self.placeID = placeID
        }

        private enum CodingKeys: String, CodingKey {
            case coordinates
            case placeID = "place_id"
        }
    }

    /// Nonpublic engagement metrics for the Tweet at the time of the request.
    public struct NonPublicMetrics: Codable {
        /// Number of times this Tweet has been viewed.
        public var impressionCount: Int?

        public init(impressionCount: Int? = nil) {
            self.impressionCount = impressionCount
        }

        private enum CodingKeys: String, CodingKey {
            case impressionCount = "impression_count"
        }
    }

    /// Organic nonpublic engagement metrics for the Tweet at the time of the request.
    public struct OrganicMetrics: Codable {
        /// Number of times this Tweet has been viewed.
        public var impressionCount: Int
        /// Number of times this Tweet has been liked.
        public var likeCount: Int
        /// Number of times this Tweet has been replied to.
        public var replyCount: Int
        /// Number of times this Tweet has been Retweeted.
        public var retweetCount: Int

        public init(impressionCount: Int, likeCount: Int, replyCount: Int, retweetCount: Int) {
            self.impressionCount = impressionCount
            self.likeCount = likeCount
            self.replyCount = replyCount
            self.retweetCount = retweetCount
        }

        private enum CodingKeys: String, CodingKey {
            case impressionCount = "impression_count"
            case likeCount = "like_count"
            case replyCount = "reply_count"
            case retweetCount = "retweet_count"
        }
    }

    /// Promoted nonpublic engagement metrics for the Tweet at the time of the request.
    public struct PromotedMetrics: Codable {
        /// Number of times this Tweet has been viewed.
        public var impressionCount: Int?
        /// Number of times this Tweet has been liked.
        public var likeCount: Int?
        /// Number of times this Tweet has been replied to.
        public var replyCount: Int?
        /// Number of times this Tweet has been Retweeted.
        public var retweetCount: Int?

        public init(impressionCount: Int? = nil, likeCount: Int? = nil, replyCount: Int? = nil, retweetCount: Int? = nil) {
            self.impressionCount = impressionCount
            self.likeCount = likeCount
            self.replyCount = replyCount
            self.retweetCount = retweetCount
        }

        private enum CodingKeys: String, CodingKey {
            case impressionCount = "impression_count"
            case likeCount = "like_count"
            case replyCount = "reply_count"
            case retweetCount = "retweet_count"
        }
    }

    /// Engagement metrics for the Tweet at the time of the request.
    public struct PublicMetrics: Codable {
        /// Number of times this Tweet has been liked.
        public var likeCount: Int
        /// Number of times this Tweet has been quoted.
        public var quoteCount: Int?
        /// Number of times this Tweet has been replied to.
        public var replyCount: Int
        /// Number of times this Tweet has been Retweeted.
        public var retweetCount: Int

        public init(likeCount: Int, quoteCount: Int? = nil, replyCount: Int, retweetCount: Int) {
            self.likeCount = likeCount
            self.quoteCount = quoteCount
            self.replyCount = replyCount
            self.retweetCount = retweetCount
        }

        private enum CodingKeys: String, CodingKey {
            case likeCount = "like_count"
            case quoteCount = "quote_count"
            case replyCount = "reply_count"
            case retweetCount = "retweet_count"
        }
    }

    public struct ReferencedTweet: Codable {
        /// Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
        ///
        /// Example: "1346889436626259968"
        public var id: String
        public var type: `Type`

        public enum `Type`: String, Codable, CaseIterable {
            case retweeted
            case quoted
            case repliedTo = "replied_to"
        }

        public init(id: String, type: `Type`) {
            self.id = id
            self.type = type
        }
    }

    public init(attachments: Attachments? = nil, authorID: String? = nil, contextAnnotations: [ContextAnnotation]? = nil, conversationID: String? = nil, createdAt: Date? = nil, entities: FullTextEntities? = nil, geo: Geo? = nil, id: String, inReplyToUserID: String? = nil, lang: String? = nil, nonPublicMetrics: NonPublicMetrics? = nil, organicMetrics: OrganicMetrics? = nil, isPossiblySensitive: Bool? = nil, promotedMetrics: PromotedMetrics? = nil, publicMetrics: PublicMetrics? = nil, referencedTweets: [ReferencedTweet]? = nil, replySettings: ReplySettings? = nil, source: String? = nil, text: String, withheld: TweetWithheld? = nil) {
        self.attachments = attachments
        self.authorID = authorID
        self.contextAnnotations = contextAnnotations
        self.conversationID = conversationID
        self.createdAt = createdAt
        self.entities = entities
        self.geo = geo
        self.id = id
        self.inReplyToUserID = inReplyToUserID
        self.lang = lang
        self.nonPublicMetrics = nonPublicMetrics
        self.organicMetrics = organicMetrics
        self.isPossiblySensitive = isPossiblySensitive
        self.promotedMetrics = promotedMetrics
        self.publicMetrics = publicMetrics
        self.referencedTweets = referencedTweets
        self.replySettings = replySettings
        self.source = source
        self.text = text
        self.withheld = withheld
    }

    private enum CodingKeys: String, CodingKey {
        case attachments
        case authorID = "author_id"
        case contextAnnotations = "context_annotations"
        case conversationID = "conversation_id"
        case createdAt = "created_at"
        case entities
        case geo
        case id
        case inReplyToUserID = "in_reply_to_user_id"
        case lang
        case nonPublicMetrics = "non_public_metrics"
        case organicMetrics = "organic_metrics"
        case isPossiblySensitive = "possibly_sensitive"
        case promotedMetrics = "promoted_metrics"
        case publicMetrics = "public_metrics"
        case referencedTweets = "referenced_tweets"
        case replySettings = "reply_settings"
        case source
        case text
        case withheld
    }
}

/// Tweet compliance data.
public enum TweetComplianceData: Codable {
    case tweetDeleteComplianceSchema(TweetDeleteComplianceSchema)
    case tweetWithheldComplianceSchema(TweetWithheldComplianceSchema)
    case tweetDropComplianceSchema(TweetDropComplianceSchema)
    case tweetUndropComplianceSchema(TweetUndropComplianceSchema)

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let value = try? container.decode(TweetDeleteComplianceSchema.self) {
            self = .tweetDeleteComplianceSchema(value)
        } else if let value = try? container.decode(TweetWithheldComplianceSchema.self) {
            self = .tweetWithheldComplianceSchema(value)
        } else if let value = try? container.decode(TweetDropComplianceSchema.self) {
            self = .tweetDropComplianceSchema(value)
        } else if let value = try? container.decode(TweetUndropComplianceSchema.self) {
            self = .tweetUndropComplianceSchema(value)
        } else {
            throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .tweetDeleteComplianceSchema(let value): try container.encode(value)
        case .tweetWithheldComplianceSchema(let value): try container.encode(value)
        case .tweetDropComplianceSchema(let value): try container.encode(value)
        case .tweetUndropComplianceSchema(let value): try container.encode(value)
        }
    }
}

public struct TweetComplianceSchema: Codable {
    /// Event time.
    ///
    /// Example: "2021-07-06T18:40:40.000Z"
    public var eventAt: Date
    public var tweet: Tweet

    public struct Tweet: Codable {
        /// Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
        ///
        /// Example: "2244994945"
        public var authorID: String
        /// Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
        ///
        /// Example: "1346889436626259968"
        public var id: String

        public init(authorID: String, id: String) {
            self.authorID = authorID
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case authorID = "author_id"
            case id
        }
    }

    public init(eventAt: Date, tweet: Tweet) {
        self.eventAt = eventAt
        self.tweet = tweet
    }

    private enum CodingKeys: String, CodingKey {
        case eventAt = "event_at"
        case tweet
    }
}

/// Tweet compliance stream events.
public enum TweetComplianceStreamResponse: Codable {
    case a(A)
    case b(B)

    /// Compliance event.
    public struct A: Codable {
        /// Tweet compliance data.
        public var data: TweetComplianceData

        public init(data: TweetComplianceData) {
            self.data = data
        }
    }

    public struct B: Codable {
        public var errors: [Problem]

        public init(errors: [Problem]) {
            self.errors = errors
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let value = try? container.decode(A.self) {
            self = .a(value)
        } else if let value = try? container.decode(B.self) {
            self = .b(value)
        } else {
            throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .a(let value): try container.encode(value)
        case .b(let value): try container.encode(value)
        }
    }
}

public struct TweetCreateRequest: Codable {
    /// Link to take the conversation from the public timeline to a private Direct Message.
    public var directMessageDeepLink: String?
    /// Exclusive Tweet for super followers.
    public var isForSuperFollowersOnly: Bool
    /// Place ID being attached to the Tweet for geo location.
    public var geo: Geo?
    /// Media information being attached to created Tweet. This is mutually exclusive from Quote Tweet Id and Poll.
    public var media: Media?
    /// Poll options for a Tweet with a poll. This is mutually exclusive from Media and Quote Tweet Id.
    public var poll: Poll?
    /// Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
    ///
    /// Example: "1346889436626259968"
    public var quoteTweetID: String?
    /// Tweet information of the Tweet being replied to.
    public var reply: Reply?
    /// Settings to indicate who can reply to the Tweet.
    public var replySettings: ReplySettings?
    /// The content of the Tweet.
    ///
    /// Example: "Learn how to use the user Tweet timeline and user mention timeline endpoints in the Twitter API v2 to explore Tweet\u2026 https:\/\/t.co\/56a0vZUx7i"
    public var text: String?

    /// Place ID being attached to the Tweet for geo location.
    public struct Geo: Codable {
        public var placeID: String?

        public init(placeID: String? = nil) {
            self.placeID = placeID
        }

        private enum CodingKeys: String, CodingKey {
            case placeID = "place_id"
        }
    }

    /// Media information being attached to created Tweet. This is mutually exclusive from Quote Tweet Id and Poll.
    public struct Media: Codable {
        /// A list of Media Ids to be attached to a created Tweet.
        public var mediaIDs: [String]
        /// A list of User Ids to be tagged in the media for created Tweet.
        public var taggedUserIDs: [String]?

        public init(mediaIDs: [String], taggedUserIDs: [String]? = nil) {
            self.mediaIDs = mediaIDs
            self.taggedUserIDs = taggedUserIDs
        }

        private enum CodingKeys: String, CodingKey {
            case mediaIDs = "media_ids"
            case taggedUserIDs = "tagged_user_ids"
        }
    }

    /// Poll options for a Tweet with a poll. This is mutually exclusive from Media and Quote Tweet Id.
    public struct Poll: Codable {
        /// Duration of the poll in minutes.
        public var durationMinutes: Int
        public var options: [String]
        /// Settings to indicate who can reply to the Tweet.
        public var replySettings: ReplySettings?

        /// Settings to indicate who can reply to the Tweet.
        public enum ReplySettings: String, Codable, CaseIterable {
            case following
            case mentionedUsers
        }

        public init(durationMinutes: Int, options: [String], replySettings: ReplySettings? = nil) {
            self.durationMinutes = durationMinutes
            self.options = options
            self.replySettings = replySettings
        }

        private enum CodingKeys: String, CodingKey {
            case durationMinutes = "duration_minutes"
            case options
            case replySettings = "reply_settings"
        }
    }

    /// Tweet information of the Tweet being replied to.
    public struct Reply: Codable {
        /// A list of User Ids to be excluded from the reply Tweet.
        public var excludeReplyUserIDs: [String]?
        /// Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
        ///
        /// Example: "1346889436626259968"
        public var inReplyToTweetID: String

        public init(excludeReplyUserIDs: [String]? = nil, inReplyToTweetID: String) {
            self.excludeReplyUserIDs = excludeReplyUserIDs
            self.inReplyToTweetID = inReplyToTweetID
        }

        private enum CodingKeys: String, CodingKey {
            case excludeReplyUserIDs = "exclude_reply_user_ids"
            case inReplyToTweetID = "in_reply_to_tweet_id"
        }
    }

    /// Settings to indicate who can reply to the Tweet.
    public enum ReplySettings: String, Codable, CaseIterable {
        case following
        case mentionedUsers
    }

    public init(directMessageDeepLink: String? = nil, isForSuperFollowersOnly: Bool? = nil, geo: Geo? = nil, media: Media? = nil, poll: Poll? = nil, quoteTweetID: String? = nil, reply: Reply? = nil, replySettings: ReplySettings? = nil, text: String? = nil) {
        self.directMessageDeepLink = directMessageDeepLink
        self.isForSuperFollowersOnly = isForSuperFollowersOnly ?? false
        self.geo = geo
        self.media = media
        self.poll = poll
        self.quoteTweetID = quoteTweetID
        self.reply = reply
        self.replySettings = replySettings
        self.text = text
    }

    private enum CodingKeys: String, CodingKey {
        case directMessageDeepLink = "direct_message_deep_link"
        case isForSuperFollowersOnly = "for_super_followers_only"
        case geo
        case media
        case poll
        case quoteTweetID = "quote_tweet_id"
        case reply
        case replySettings = "reply_settings"
        case text
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.directMessageDeepLink = try values.decodeIfPresent(String.self, forKey: .directMessageDeepLink)
        self.isForSuperFollowersOnly = try values.decodeIfPresent(Bool.self, forKey: .isForSuperFollowersOnly) ?? false
        self.geo = try values.decodeIfPresent(Geo.self, forKey: .geo)
        self.media = try values.decodeIfPresent(Media.self, forKey: .media)
        self.poll = try values.decodeIfPresent(Poll.self, forKey: .poll)
        self.quoteTweetID = try values.decodeIfPresent(String.self, forKey: .quoteTweetID)
        self.reply = try values.decodeIfPresent(Reply.self, forKey: .reply)
        self.replySettings = try values.decodeIfPresent(ReplySettings.self, forKey: .replySettings)
        self.text = try values.decodeIfPresent(String.self, forKey: .text)
    }
}

public struct TweetCreateResponse: Codable {
    public var data: Data?
    public var errors: [Problem]?

    public struct Data: Codable {
        /// Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
        ///
        /// Example: "1346889436626259968"
        public var id: String
        /// The content of the Tweet.
        ///
        /// Example: "Learn how to use the user Tweet timeline and user mention timeline endpoints in the Twitter API v2 to explore Tweet\u2026 https:\/\/t.co\/56a0vZUx7i"
        public var text: String

        public init(id: String, text: String) {
            self.id = id
            self.text = text
        }
    }

    public init(data: Data? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

public struct TweetDeleteComplianceSchema: Codable {
    public var delete: TweetComplianceSchema

    public init(delete: TweetComplianceSchema) {
        self.delete = delete
    }
}

public struct TweetDeleteResponse: Codable {
    public var data: Data?
    public var errors: [Problem]?

    public struct Data: Codable {
        public var isDeleted: Bool

        public init(isDeleted: Bool) {
            self.isDeleted = isDeleted
        }

        private enum CodingKeys: String, CodingKey {
            case isDeleted = "deleted"
        }
    }

    public init(data: Data? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

public struct TweetDropComplianceSchema: Codable {
    public var drop: TweetComplianceSchema

    public init(drop: TweetComplianceSchema) {
        self.drop = drop
    }
}

public struct TweetHideRequest: Codable {
    public var isHidden: Bool

    public init(isHidden: Bool) {
        self.isHidden = isHidden
    }

    private enum CodingKeys: String, CodingKey {
        case isHidden = "hidden"
    }
}

public struct TweetHideResponse: Codable {
    public var data: Data?

    public struct Data: Codable {
        public var isHidden: Bool?

        public init(isHidden: Bool? = nil) {
            self.isHidden = isHidden
        }

        private enum CodingKeys: String, CodingKey {
            case isHidden = "hidden"
        }
    }

    public init(data: Data? = nil) {
        self.data = data
    }
}

public struct TweetTakedownComplianceSchema: Codable {
    /// Event time.
    ///
    /// Example: "2021-07-06T18:40:40.000Z"
    public var eventAt: Date
    public var tweet: Tweet
    public var withheldInCountries: [String]

    public struct Tweet: Codable {
        /// Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
        ///
        /// Example: "2244994945"
        public var authorID: String
        /// Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
        ///
        /// Example: "1346889436626259968"
        public var id: String

        public init(authorID: String, id: String) {
            self.authorID = authorID
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case authorID = "author_id"
            case id
        }
    }

    public init(eventAt: Date, tweet: Tweet, withheldInCountries: [String]) {
        self.eventAt = eventAt
        self.tweet = tweet
        self.withheldInCountries = withheldInCountries
    }

    private enum CodingKeys: String, CodingKey {
        case eventAt = "event_at"
        case tweet
        case withheldInCountries = "withheld_in_countries"
    }
}

public struct TweetUndropComplianceSchema: Codable {
    public var undrop: TweetComplianceSchema

    public init(undrop: TweetComplianceSchema) {
        self.undrop = undrop
    }
}

/// Indicates withholding details for [withheld content](https://help.twitter.com/en/rules-and-policies/tweet-withheld-by-country).
public struct TweetWithheld: Codable {
    /// Indicates if the content is being withheld for on the basis of copyright infringement.
    public var isCopyright: Bool
    /// Provides a list of countries where this content is not available.
    public var countryCodes: [String]
    /// Indicates whether the content being withheld is the `tweet` or a `user`.
    public var scope: Scope?

    /// Indicates whether the content being withheld is the `tweet` or a `user`.
    public enum Scope: String, Codable, CaseIterable {
        case tweet
        case user
    }

    public init(isCopyright: Bool, countryCodes: [String], scope: Scope? = nil) {
        self.isCopyright = isCopyright
        self.countryCodes = countryCodes
        self.scope = scope
    }

    private enum CodingKeys: String, CodingKey {
        case isCopyright = "copyright"
        case countryCodes = "country_codes"
        case scope
    }
}

public struct TweetWithheldComplianceSchema: Codable {
    public var withheld: TweetTakedownComplianceSchema

    public init(withheld: TweetTakedownComplianceSchema) {
        self.withheld = withheld
    }
}

/// Represent the portion of text recognized as a URL, and its start and end position within the text.
public struct URLEntity: Codable {
    /// Represent a boundary range (start and end index) for a recognized entity (for example a hashtag or a mention). `start` must be smaller than `end`.  The start index is inclusive, the end index is exclusive.
    public var entityIndicesInclusiveExclusive: EntityIndicesInclusiveExclusive
    /// Represent the portion of text recognized as a URL.
    public var urlFields: URLFields

    public init(entityIndicesInclusiveExclusive: EntityIndicesInclusiveExclusive, urlFields: URLFields) {
        self.entityIndicesInclusiveExclusive = entityIndicesInclusiveExclusive
        self.urlFields = urlFields
    }

    public init(from decoder: Decoder) throws {
        self.entityIndicesInclusiveExclusive = try EntityIndicesInclusiveExclusive(from: decoder)
        self.urlFields = try URLFields(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(entityIndicesInclusiveExclusive, forKey: "entityIndicesInclusiveExclusive")
        try values.encode(urlFields, forKey: "urlFields")
    }
}

/// Represent the portion of text recognized as a URL.
public struct URLFields: Codable {
    /// Description of the URL landing page.
    ///
    /// Example: "This is a description of the website."
    public var description: String?
    /// The URL as displayed in the Twitter client.
    ///
    /// Example: "twittercommunity.com/t/introducing-"
    public var displayURL: String?
    /// A validly formatted URL.
    ///
    /// Example: "https://developer.twitter.com/en/docs/twitter-api"
    public var expandedURL: URL?
    public var images: [URLImage]?
    /// The Media Key identifier for this attachment.
    public var mediaKey: String?
    /// HTTP Status Code.
    public var status: Int?
    /// Title of the page the URL points to.
    ///
    /// Example: "Introducing the v2 follow lookup endpoints"
    public var title: String?
    /// Fully resolved url.
    ///
    /// Example: "https://twittercommunity.com/t/introducing-the-v2-follow-lookup-endpoints/147118"
    public var unwoundURL: URL?
    /// A validly formatted URL.
    ///
    /// Example: "https://developer.twitter.com/en/docs/twitter-api"
    public var url: URL

    public init(description: String? = nil, displayURL: String? = nil, expandedURL: URL? = nil, images: [URLImage]? = nil, mediaKey: String? = nil, status: Int? = nil, title: String? = nil, unwoundURL: URL? = nil, url: URL) {
        self.description = description
        self.displayURL = displayURL
        self.expandedURL = expandedURL
        self.images = images
        self.mediaKey = mediaKey
        self.status = status
        self.title = title
        self.unwoundURL = unwoundURL
        self.url = url
    }

    private enum CodingKeys: String, CodingKey {
        case description
        case displayURL = "display_url"
        case expandedURL = "expanded_url"
        case images
        case mediaKey = "media_key"
        case status
        case title
        case unwoundURL = "unwound_url"
        case url
    }
}

/// Represent the information for the URL image.
public struct URLImage: Codable {
    /// The height of the media in pixels.
    public var height: Int?
    /// A validly formatted URL.
    ///
    /// Example: "https://developer.twitter.com/en/docs/twitter-api"
    public var url: URL?
    /// The width of the media in pixels.
    public var width: Int?

    public init(height: Int? = nil, url: URL? = nil, width: Int? = nil) {
        self.height = height
        self.url = url
        self.width = width
    }
}

/// A problem that indicates that a usage cap has been exceeded.
public struct UsageCapExceededProblem: Codable {
    /// An HTTP Problem Details object, as defined in IETF RFC 7807 (https://tools.ietf.org/html/rfc7807).
    public var problem: Problem
    public var period: Period?
    public var scope: Scope?

    public enum Period: String, Codable, CaseIterable {
        case daily = "Daily"
        case monthly = "Monthly"
    }

    public enum Scope: String, Codable, CaseIterable {
        case account = "Account"
        case product = "Product"
    }

    public init(problem: Problem, period: Period? = nil, scope: Scope? = nil) {
        self.problem = problem
        self.period = period
        self.scope = scope
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.problem = try Problem(from: decoder)
        self.period = try values.decodeIfPresent(Period.self, forKey: "period")
        self.scope = try values.decodeIfPresent(Scope.self, forKey: "scope")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(problem, forKey: "problem")
        try values.encodeIfPresent(period, forKey: "period")
        try values.encodeIfPresent(scope, forKey: "scope")
    }
}

/// The Twitter User object.
///
/// Example:
///
/// {
///   "created_at" : "2013-12-14T04:35:55Z",
///   "id" : "2244994945",
///   "name" : "Twitter Dev",
///   "protected" : false,
///   "username" : "TwitterDev"
/// }
public struct User: Codable {
    /// Creation time of this User.
    public var createdAt: Date?
    /// The text of this User's profile description (also known as bio), if the User provided one.
    public var description: String?
    /// A list of metadata found in the User's profile description.
    public var entities: Entities?
    /// Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
    ///
    /// Example: "2244994945"
    public var id: String
    /// The location specified in the User's profile, if the User provided one. As this is a freeform value, it may not indicate a valid location, but it may be fuzzily evaluated when performing searches with location queries.
    public var location: String?
    /// The friendly name of this User, as shown on their profile.
    public var name: String
    /// Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
    ///
    /// Example: "1346889436626259968"
    public var pinnedTweetID: String?
    /// The URL to the profile image for this User.
    public var profileImageURL: URL?
    /// Indicates if this User has chosen to protect their Tweets (in other words, if this User's Tweets are private).
    public var isProtected: Bool?
    /// A list of metrics for this User.
    public var publicMetrics: PublicMetrics?
    /// The URL specified in the User's profile.
    public var url: String?
    /// The Twitter handle (screen name) of this user.
    public var username: String
    /// Indicate if this User is a verified Twitter User.
    public var isVerified: Bool?
    /// Indicates withholding details for [withheld content](https://help.twitter.com/en/rules-and-policies/tweet-withheld-by-country).
    public var withheld: UserWithheld?

    /// A list of metadata found in the User's profile description.
    public struct Entities: Codable {
        public var description: FullTextEntities?
        /// Expanded details for the URL specified in the User's profile, with start and end indices.
        public var url: URL?

        /// Expanded details for the URL specified in the User's profile, with start and end indices.
        public struct URL: Codable {
            public var urls: [URLEntity]?

            public init(urls: [URLEntity]? = nil) {
                self.urls = urls
            }
        }

        public init(description: FullTextEntities? = nil, url: URL? = nil) {
            self.description = description
            self.url = url
        }
    }

    /// A list of metrics for this User.
    public struct PublicMetrics: Codable {
        /// Number of Users who are following this User.
        public var followersCount: Int
        /// Number of Users this User is following.
        public var followingCount: Int
        /// The number of lists that include this User.
        public var listedCount: Int
        /// The number of Tweets (including Retweets) posted by this User.
        public var tweetCount: Int

        public init(followersCount: Int, followingCount: Int, listedCount: Int, tweetCount: Int) {
            self.followersCount = followersCount
            self.followingCount = followingCount
            self.listedCount = listedCount
            self.tweetCount = tweetCount
        }

        private enum CodingKeys: String, CodingKey {
            case followersCount = "followers_count"
            case followingCount = "following_count"
            case listedCount = "listed_count"
            case tweetCount = "tweet_count"
        }
    }

    public init(createdAt: Date? = nil, description: String? = nil, entities: Entities? = nil, id: String, location: String? = nil, name: String, pinnedTweetID: String? = nil, profileImageURL: URL? = nil, isProtected: Bool? = nil, publicMetrics: PublicMetrics? = nil, url: String? = nil, username: String, isVerified: Bool? = nil, withheld: UserWithheld? = nil) {
        self.createdAt = createdAt
        self.description = description
        self.entities = entities
        self.id = id
        self.location = location
        self.name = name
        self.pinnedTweetID = pinnedTweetID
        self.profileImageURL = profileImageURL
        self.isProtected = isProtected
        self.publicMetrics = publicMetrics
        self.url = url
        self.username = username
        self.isVerified = isVerified
        self.withheld = withheld
    }

    private enum CodingKeys: String, CodingKey {
        case createdAt = "created_at"
        case description
        case entities
        case id
        case location
        case name
        case pinnedTweetID = "pinned_tweet_id"
        case profileImageURL = "profile_image_url"
        case isProtected = "protected"
        case publicMetrics = "public_metrics"
        case url
        case username
        case isVerified = "verified"
        case withheld
    }
}

/// User compliance data.
public enum UserComplianceData: Codable {
    case userProtectComplianceSchema(UserProtectComplianceSchema)
    case userUnprotectComplianceSchema(UserUnprotectComplianceSchema)
    case userDeleteComplianceSchema(UserDeleteComplianceSchema)
    case userUndeleteComplianceSchema(UserUndeleteComplianceSchema)
    case userSuspendComplianceSchema(UserSuspendComplianceSchema)
    case userUnsuspendComplianceSchema(UserUnsuspendComplianceSchema)
    case userWithheldComplianceSchema(UserWithheldComplianceSchema)
    case userScrubGeoSchema(UserScrubGeoSchema)

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let value = try? container.decode(UserProtectComplianceSchema.self) {
            self = .userProtectComplianceSchema(value)
        } else if let value = try? container.decode(UserUnprotectComplianceSchema.self) {
            self = .userUnprotectComplianceSchema(value)
        } else if let value = try? container.decode(UserDeleteComplianceSchema.self) {
            self = .userDeleteComplianceSchema(value)
        } else if let value = try? container.decode(UserUndeleteComplianceSchema.self) {
            self = .userUndeleteComplianceSchema(value)
        } else if let value = try? container.decode(UserSuspendComplianceSchema.self) {
            self = .userSuspendComplianceSchema(value)
        } else if let value = try? container.decode(UserUnsuspendComplianceSchema.self) {
            self = .userUnsuspendComplianceSchema(value)
        } else if let value = try? container.decode(UserWithheldComplianceSchema.self) {
            self = .userWithheldComplianceSchema(value)
        } else if let value = try? container.decode(UserScrubGeoSchema.self) {
            self = .userScrubGeoSchema(value)
        } else {
            throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .userProtectComplianceSchema(let value): try container.encode(value)
        case .userUnprotectComplianceSchema(let value): try container.encode(value)
        case .userDeleteComplianceSchema(let value): try container.encode(value)
        case .userUndeleteComplianceSchema(let value): try container.encode(value)
        case .userSuspendComplianceSchema(let value): try container.encode(value)
        case .userUnsuspendComplianceSchema(let value): try container.encode(value)
        case .userWithheldComplianceSchema(let value): try container.encode(value)
        case .userScrubGeoSchema(let value): try container.encode(value)
        }
    }
}

public struct UserComplianceSchema: Codable {
    /// Event time.
    ///
    /// Example: "2021-07-06T18:40:40.000Z"
    public var eventAt: Date
    public var user: User

    public struct User: Codable {
        /// Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
        ///
        /// Example: "2244994945"
        public var id: String

        public init(id: String) {
            self.id = id
        }
    }

    public init(eventAt: Date, user: User) {
        self.eventAt = eventAt
        self.user = user
    }

    private enum CodingKeys: String, CodingKey {
        case eventAt = "event_at"
        case user
    }
}

/// User compliance stream events.
public enum UserComplianceStreamResponse: Codable {
    case a(A)
    case b(B)

    /// User compliance event.
    public struct A: Codable {
        /// User compliance data.
        public var data: UserComplianceData

        public init(data: UserComplianceData) {
            self.data = data
        }
    }

    public struct B: Codable {
        public var errors: [Problem]

        public init(errors: [Problem]) {
            self.errors = errors
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let value = try? container.decode(A.self) {
            self = .a(value)
        } else if let value = try? container.decode(B.self) {
            self = .b(value)
        } else {
            throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .a(let value): try container.encode(value)
        case .b(let value): try container.encode(value)
        }
    }
}

public struct UserDeleteComplianceSchema: Codable {
    public var userDelete: UserComplianceSchema

    public init(userDelete: UserComplianceSchema) {
        self.userDelete = userDelete
    }

    private enum CodingKeys: String, CodingKey {
        case userDelete = "user_delete"
    }
}

public struct UserProtectComplianceSchema: Codable {
    public var userProtect: UserComplianceSchema

    public init(userProtect: UserComplianceSchema) {
        self.userProtect = userProtect
    }

    private enum CodingKeys: String, CodingKey {
        case userProtect = "user_protect"
    }
}

public struct UserScrubGeoObjectSchema: Codable {
    /// Event time.
    ///
    /// Example: "2021-07-06T18:40:40.000Z"
    public var eventAt: Date
    /// Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
    ///
    /// Example: "1346889436626259968"
    public var upToTweetID: String
    public var user: User

    public struct User: Codable {
        /// Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
        ///
        /// Example: "2244994945"
        public var id: String

        public init(id: String) {
            self.id = id
        }
    }

    public init(eventAt: Date, upToTweetID: String, user: User) {
        self.eventAt = eventAt
        self.upToTweetID = upToTweetID
        self.user = user
    }

    private enum CodingKeys: String, CodingKey {
        case eventAt = "event_at"
        case upToTweetID = "up_to_tweet_id"
        case user
    }
}

public struct UserScrubGeoSchema: Codable {
    public var scrubGeo: UserScrubGeoObjectSchema

    public init(scrubGeo: UserScrubGeoObjectSchema) {
        self.scrubGeo = scrubGeo
    }

    private enum CodingKeys: String, CodingKey {
        case scrubGeo = "scrub_geo"
    }
}

public struct UserSuspendComplianceSchema: Codable {
    public var userSuspend: UserComplianceSchema

    public init(userSuspend: UserComplianceSchema) {
        self.userSuspend = userSuspend
    }

    private enum CodingKeys: String, CodingKey {
        case userSuspend = "user_suspend"
    }
}

public struct UserTakedownComplianceSchema: Codable {
    /// Event time.
    ///
    /// Example: "2021-07-06T18:40:40.000Z"
    public var eventAt: Date
    public var user: User
    public var withheldInCountries: [String]

    public struct User: Codable {
        /// Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
        ///
        /// Example: "2244994945"
        public var id: String

        public init(id: String) {
            self.id = id
        }
    }

    public init(eventAt: Date, user: User, withheldInCountries: [String]) {
        self.eventAt = eventAt
        self.user = user
        self.withheldInCountries = withheldInCountries
    }

    private enum CodingKeys: String, CodingKey {
        case eventAt = "event_at"
        case user
        case withheldInCountries = "withheld_in_countries"
    }
}

public struct UserUndeleteComplianceSchema: Codable {
    public var userUndelete: UserComplianceSchema

    public init(userUndelete: UserComplianceSchema) {
        self.userUndelete = userUndelete
    }

    private enum CodingKeys: String, CodingKey {
        case userUndelete = "user_undelete"
    }
}

public struct UserUnprotectComplianceSchema: Codable {
    public var userUnprotect: UserComplianceSchema

    public init(userUnprotect: UserComplianceSchema) {
        self.userUnprotect = userUnprotect
    }

    private enum CodingKeys: String, CodingKey {
        case userUnprotect = "user_unprotect"
    }
}

public struct UserUnsuspendComplianceSchema: Codable {
    public var userUnsuspend: UserComplianceSchema

    public init(userUnsuspend: UserComplianceSchema) {
        self.userUnsuspend = userUnsuspend
    }

    private enum CodingKeys: String, CodingKey {
        case userUnsuspend = "user_unsuspend"
    }
}

/// Indicates withholding details for [withheld content](https://help.twitter.com/en/rules-and-policies/tweet-withheld-by-country).
public struct UserWithheld: Codable {
    /// Provides a list of countries where this content is not available.
    public var countryCodes: [String]
    /// Indicates that the content being withheld is a `user`.
    public var scope: Scope?

    /// Indicates that the content being withheld is a `user`.
    public enum Scope: String, Codable, CaseIterable {
        case user
    }

    public init(countryCodes: [String], scope: Scope? = nil) {
        self.countryCodes = countryCodes
        self.scope = scope
    }

    private enum CodingKeys: String, CodingKey {
        case countryCodes = "country_codes"
        case scope
    }
}

public struct UserWithheldComplianceSchema: Codable {
    public var userWithheld: UserTakedownComplianceSchema

    public init(userWithheld: UserTakedownComplianceSchema) {
        self.userWithheld = userWithheld
    }

    private enum CodingKeys: String, CodingKey {
        case userWithheld = "user_withheld"
    }
}

public struct UsersFollowingCreateRequest: Codable {
    /// Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
    ///
    /// Example: "2244994945"
    public var targetUserID: String

    public init(targetUserID: String) {
        self.targetUserID = targetUserID
    }

    private enum CodingKeys: String, CodingKey {
        case targetUserID = "target_user_id"
    }
}

public struct UsersFollowingCreateResponse: Codable {
    public var data: Data?
    public var errors: [Problem]?

    public struct Data: Codable {
        public var isFollowing: Bool?
        public var isPendingFollow: Bool?

        public init(isFollowing: Bool? = nil, isPendingFollow: Bool? = nil) {
            self.isFollowing = isFollowing
            self.isPendingFollow = isPendingFollow
        }

        private enum CodingKeys: String, CodingKey {
            case isFollowing = "following"
            case isPendingFollow = "pending_follow"
        }
    }

    public init(data: Data? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

public struct UsersFollowingDeleteResponse: Codable {
    public var data: Data?
    public var errors: [Problem]?

    public struct Data: Codable {
        public var isFollowing: Bool?

        public init(isFollowing: Bool? = nil) {
            self.isFollowing = isFollowing
        }

        private enum CodingKeys: String, CodingKey {
            case isFollowing = "following"
        }
    }

    public init(data: Data? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

public struct UsersLikesCreateRequest: Codable {
    /// Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
    ///
    /// Example: "1346889436626259968"
    public var tweetID: String

    public init(tweetID: String) {
        self.tweetID = tweetID
    }

    private enum CodingKeys: String, CodingKey {
        case tweetID = "tweet_id"
    }
}

public struct UsersLikesCreateResponse: Codable {
    public var data: Data?
    public var errors: [Problem]?

    public struct Data: Codable {
        public var isLiked: Bool?

        public init(isLiked: Bool? = nil) {
            self.isLiked = isLiked
        }

        private enum CodingKeys: String, CodingKey {
            case isLiked = "liked"
        }
    }

    public init(data: Data? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

public struct UsersLikesDeleteResponse: Codable {
    public var data: Data?
    public var errors: [Problem]?

    public struct Data: Codable {
        public var isLiked: Bool?

        public init(isLiked: Bool? = nil) {
            self.isLiked = isLiked
        }

        private enum CodingKeys: String, CodingKey {
            case isLiked = "liked"
        }
    }

    public init(data: Data? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

public struct UsersRetweetsCreateRequest: Codable {
    /// Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
    ///
    /// Example: "1346889436626259968"
    public var tweetID: String

    public init(tweetID: String) {
        self.tweetID = tweetID
    }

    private enum CodingKeys: String, CodingKey {
        case tweetID = "tweet_id"
    }
}

public struct UsersRetweetsCreateResponse: Codable {
    public var data: Data?
    public var errors: [Problem]?

    public struct Data: Codable {
        public var isRetweeted: Bool?

        public init(isRetweeted: Bool? = nil) {
            self.isRetweeted = isRetweeted
        }

        private enum CodingKeys: String, CodingKey {
            case isRetweeted = "retweeted"
        }
    }

    public init(data: Data? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

public struct UsersRetweetsDeleteResponse: Codable {
    public var data: Data?
    public var errors: [Problem]?

    public struct Data: Codable {
        public var isRetweeted: Bool?

        public init(isRetweeted: Bool? = nil) {
            self.isRetweeted = isRetweeted
        }

        private enum CodingKeys: String, CodingKey {
            case isRetweeted = "retweeted"
        }
    }

    public init(data: Data? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

public struct Variant: Codable {
    /// The bit rate of the media.
    public var bitRate: Int?
    /// The content type of the media.
    public var contentType: String?
    /// The url to the media.
    public var url: URL?

    public init(bitRate: Int? = nil, contentType: String? = nil, url: URL? = nil) {
        self.bitRate = bitRate
        self.contentType = contentType
        self.url = url
    }

    private enum CodingKeys: String, CodingKey {
        case bitRate = "bit_rate"
        case contentType = "content_type"
        case url
    }
}

public struct Video: Codable {
    public var media: Media
    public var durationMs: Int?
    /// Nonpublic engagement metrics for the Media at the time of the request.
    public var nonPublicMetrics: NonPublicMetrics?
    /// Organic nonpublic engagement metrics for the Media at the time of the request.
    public var organicMetrics: OrganicMetrics?
    public var previewImageURL: URL?
    /// Promoted nonpublic engagement metrics for the Media at the time of the request.
    public var promotedMetrics: PromotedMetrics?
    /// Engagement metrics for the Media at the time of the request.
    public var publicMetrics: PublicMetrics?
    /// An array of all available variants of the media.
    public var variants: [Variant]?

    /// Nonpublic engagement metrics for the Media at the time of the request.
    public struct NonPublicMetrics: Codable {
        /// Number of users who made it through 0% of the video.
        public var playback0Count: Int?
        /// Number of users who made it through 100% of the video.
        public var playback100Count: Int?
        /// Number of users who made it through 25% of the video.
        public var playback25Count: Int?
        /// Number of users who made it through 50% of the video.
        public var playback50Count: Int?
        /// Number of users who made it through 75% of the video.
        public var playback75Count: Int?

        public init(playback0Count: Int? = nil, playback100Count: Int? = nil, playback25Count: Int? = nil, playback50Count: Int? = nil, playback75Count: Int? = nil) {
            self.playback0Count = playback0Count
            self.playback100Count = playback100Count
            self.playback25Count = playback25Count
            self.playback50Count = playback50Count
            self.playback75Count = playback75Count
        }

        private enum CodingKeys: String, CodingKey {
            case playback0Count = "playback_0_count"
            case playback100Count = "playback_100_count"
            case playback25Count = "playback_25_count"
            case playback50Count = "playback_50_count"
            case playback75Count = "playback_75_count"
        }
    }

    /// Organic nonpublic engagement metrics for the Media at the time of the request.
    public struct OrganicMetrics: Codable {
        /// Number of users who made it through 0% of the video.
        public var playback0Count: Int?
        /// Number of users who made it through 100% of the video.
        public var playback100Count: Int?
        /// Number of users who made it through 25% of the video.
        public var playback25Count: Int?
        /// Number of users who made it through 50% of the video.
        public var playback50Count: Int?
        /// Number of users who made it through 75% of the video.
        public var playback75Count: Int?
        /// Number of times this video has been viewed.
        public var viewCount: Int?

        public init(playback0Count: Int? = nil, playback100Count: Int? = nil, playback25Count: Int? = nil, playback50Count: Int? = nil, playback75Count: Int? = nil, viewCount: Int? = nil) {
            self.playback0Count = playback0Count
            self.playback100Count = playback100Count
            self.playback25Count = playback25Count
            self.playback50Count = playback50Count
            self.playback75Count = playback75Count
            self.viewCount = viewCount
        }

        private enum CodingKeys: String, CodingKey {
            case playback0Count = "playback_0_count"
            case playback100Count = "playback_100_count"
            case playback25Count = "playback_25_count"
            case playback50Count = "playback_50_count"
            case playback75Count = "playback_75_count"
            case viewCount = "view_count"
        }
    }

    /// Promoted nonpublic engagement metrics for the Media at the time of the request.
    public struct PromotedMetrics: Codable {
        /// Number of users who made it through 0% of the video.
        public var playback0Count: Int?
        /// Number of users who made it through 100% of the video.
        public var playback100Count: Int?
        /// Number of users who made it through 25% of the video.
        public var playback25Count: Int?
        /// Number of users who made it through 50% of the video.
        public var playback50Count: Int?
        /// Number of users who made it through 75% of the video.
        public var playback75Count: Int?
        /// Number of times this video has been viewed.
        public var viewCount: Int?

        public init(playback0Count: Int? = nil, playback100Count: Int? = nil, playback25Count: Int? = nil, playback50Count: Int? = nil, playback75Count: Int? = nil, viewCount: Int? = nil) {
            self.playback0Count = playback0Count
            self.playback100Count = playback100Count
            self.playback25Count = playback25Count
            self.playback50Count = playback50Count
            self.playback75Count = playback75Count
            self.viewCount = viewCount
        }

        private enum CodingKeys: String, CodingKey {
            case playback0Count = "playback_0_count"
            case playback100Count = "playback_100_count"
            case playback25Count = "playback_25_count"
            case playback50Count = "playback_50_count"
            case playback75Count = "playback_75_count"
            case viewCount = "view_count"
        }
    }

    /// Engagement metrics for the Media at the time of the request.
    public struct PublicMetrics: Codable {
        /// Number of times this video has been viewed.
        public var viewCount: Int?

        public init(viewCount: Int? = nil) {
            self.viewCount = viewCount
        }

        private enum CodingKeys: String, CodingKey {
            case viewCount = "view_count"
        }
    }

    public init(media: Media, durationMs: Int? = nil, nonPublicMetrics: NonPublicMetrics? = nil, organicMetrics: OrganicMetrics? = nil, previewImageURL: URL? = nil, promotedMetrics: PromotedMetrics? = nil, publicMetrics: PublicMetrics? = nil, variants: [Variant]? = nil) {
        self.media = media
        self.durationMs = durationMs
        self.nonPublicMetrics = nonPublicMetrics
        self.organicMetrics = organicMetrics
        self.previewImageURL = previewImageURL
        self.promotedMetrics = promotedMetrics
        self.publicMetrics = publicMetrics
        self.variants = variants
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.media = try Media(from: decoder)
        self.durationMs = try values.decodeIfPresent(Int.self, forKey: "duration_ms")
        self.nonPublicMetrics = try values.decodeIfPresent(NonPublicMetrics.self, forKey: "non_public_metrics")
        self.organicMetrics = try values.decodeIfPresent(OrganicMetrics.self, forKey: "organic_metrics")
        self.previewImageURL = try values.decodeIfPresent(URL.self, forKey: "preview_image_url")
        self.promotedMetrics = try values.decodeIfPresent(PromotedMetrics.self, forKey: "promoted_metrics")
        self.publicMetrics = try values.decodeIfPresent(PublicMetrics.self, forKey: "public_metrics")
        self.variants = try values.decodeIfPresent([Variant].self, forKey: "variants")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(media, forKey: "media")
        try values.encodeIfPresent(durationMs, forKey: "duration_ms")
        try values.encodeIfPresent(nonPublicMetrics, forKey: "non_public_metrics")
        try values.encodeIfPresent(organicMetrics, forKey: "organic_metrics")
        try values.encodeIfPresent(previewImageURL, forKey: "preview_image_url")
        try values.encodeIfPresent(promotedMetrics, forKey: "promoted_metrics")
        try values.encodeIfPresent(publicMetrics, forKey: "public_metrics")
        try values.encodeIfPresent(variants, forKey: "variants")
    }
}

public enum AnyJSON: Equatable, Codable {
    case string(String)
    case number(Double)
    case object([String: AnyJSON])
    case array([AnyJSON])
    case bool(Bool)

    var value: Any {
        switch self {
        case .string(let string): return string
        case .number(let double): return double
        case .object(let dictionary): return dictionary
        case .array(let array): return array
        case .bool(let bool): return bool
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case let .array(array): try container.encode(array)
        case let .object(object): try container.encode(object)
        case let .string(string): try container.encode(string)
        case let .number(number): try container.encode(number)
        case let .bool(bool): try container.encode(bool)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let object = try? container.decode([String: AnyJSON].self) {
            self = .object(object)
        } else if let array = try? container.decode([AnyJSON].self) {
            self = .array(array)
        } else if let string = try? container.decode(String.self) {
            self = .string(string)
        } else if let bool = try? container.decode(Bool.self) {
            self = .bool(bool)
        } else if let number = try? container.decode(Double.self) {
            self = .number(number)
        } else {
            throw DecodingError.dataCorrupted(
                .init(codingPath: decoder.codingPath, debugDescription: "Invalid JSON value.")
            )
        }
    }
}

struct StringCodingKey: CodingKey, ExpressibleByStringLiteral {
    private let string: String
    private var int: Int?

    var stringValue: String { return string }

    init(string: String) {
        self.string = string
    }

    init?(stringValue: String) {
        self.string = stringValue
    }

    var intValue: Int? { return int }

    init?(intValue: Int) {
        self.string = String(describing: intValue)
        self.int = intValue
    }

    init(stringLiteral value: String) {
        self.string = value
    }
}
