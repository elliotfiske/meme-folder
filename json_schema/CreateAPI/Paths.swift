// Generated by Create API
// https://github.com/CreateAPI/CreateAPI
//
// swiftlint:disable all

import Foundation
import Get
import URLQueryEncoder

extension Paths {
    public static var compliance: Compliance {
        Compliance(path: "/2/compliance")
    }

    public struct Compliance {
        /// Path: `/2/compliance`
        public let path: String
    }
}

extension Paths.Compliance {
    public var jobs: Jobs {
        Jobs(path: path + "/jobs")
    }

    public struct Jobs {
        /// Path: `/2/compliance/jobs`
        public let path: String

        /// List Compliance Jobs
        ///
        /// Returns recent Compliance Jobs for a given job type and optional job status
        public func get(parameters: GetParameters) -> Request<TwitterAPI.Get2ComplianceJobsResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var type: `Type`
            public var status: Status?
            /// The fields available for a ComplianceJob object.
            ///
            /// Example: ["created_at", "download_expires_at", "download_url", "id", "name", "resumable", "status", "type", "upload_expires_at", "upload_url"]
            public var complianceJobFields: [ComplianceJobFields]?

            public enum `Type`: String, Codable, CaseIterable {
                case tweets
                case users
            }

            public enum Status: String, Codable, CaseIterable {
                case created
                case inProgress = "in_progress"
                case failed
                case complete
            }

            public enum ComplianceJobFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case downloadExpiresAt = "download_expires_at"
                case downloadURL = "download_url"
                case id
                case name
                case resumable
                case status
                case type
                case uploadExpiresAt = "upload_expires_at"
                case uploadURL = "upload_url"
            }

            public init(type: `Type`, status: Status? = nil, complianceJobFields: [ComplianceJobFields]? = nil) {
                self.type = type
                self.status = status
                self.complianceJobFields = complianceJobFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(type, forKey: "type")
                encoder.encode(status, forKey: "status")
                encoder.encode(complianceJobFields, forKey: "compliance_job.fields", explode: false)
                return encoder.items
            }
        }

        /// Create compliance job
        ///
        /// Creates a compliance for the given job type
        public func post(_ body: TwitterAPI.CreateComplianceJobRequest) -> Request<TwitterAPI.CreateComplianceJobResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.Compliance.Jobs {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/2/compliance/jobs/{id}`
        public let path: String

        /// Get Compliance Job
        ///
        /// Returns a single Compliance Job by ID
        public func get(complianceJobFields: [ComplianceJobFields]? = nil) -> Request<TwitterAPI.Get2ComplianceJobsIDResponse> {
            .get(path, query: makeGetQuery(complianceJobFields))
        }

        private func makeGetQuery(_ complianceJobFields: [ComplianceJobFields]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(complianceJobFields, forKey: "compliance_job.fields", explode: false)
            return encoder.items
        }

        public enum ComplianceJobFields: String, Codable, CaseIterable {
            case createdAt = "created_at"
            case downloadExpiresAt = "download_expires_at"
            case downloadURL = "download_url"
            case id
            case name
            case resumable
            case status
            case type
            case uploadExpiresAt = "upload_expires_at"
            case uploadURL = "upload_url"
        }
    }
}

extension Paths {
    public static var lists: Lists {
        Lists(path: "/2/lists")
    }

    public struct Lists {
        /// Path: `/2/lists`
        public let path: String

        /// Create List
        ///
        /// Creates a new List.
        public func post(_ body: TwitterAPI.ListCreateRequest? = nil) -> Request<TwitterAPI.ListCreateResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.Lists {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/2/lists/{id}`
        public let path: String

        /// List lookup by List ID.
        ///
        /// Returns a List.
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.Get2ListsIDResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// The fields available for a List object.
            ///
            /// Example: ["created_at", "description", "follower_count", "id", "member_count", "name", "owner_id", "private"]
            public var listFields: [ListFields]?
            /// The list of fields you can expand for a [List](#List) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["owner_id"]
            public var expansions: [Expansions]?
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?

            public enum ListFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case followerCount = "follower_count"
                case id
                case memberCount = "member_count"
                case name
                case ownerID = "owner_id"
                case `private`
            }

            public enum Expansions: String, Codable, CaseIterable {
                case ownerID = "owner_id"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public init(listFields: [ListFields]? = nil, expansions: [Expansions]? = nil, userFields: [UserFields]? = nil) {
                self.listFields = listFields
                self.expansions = expansions
                self.userFields = userFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(listFields, forKey: "list.fields")
                encoder.encode(expansions, forKey: "expansions")
                encoder.encode(userFields, forKey: "user.fields")
                return encoder.items
            }
        }

        /// Update List.
        ///
        /// Update a List that you own.
        public func put(_ body: TwitterAPI.ListUpdateRequest? = nil) -> Request<TwitterAPI.ListUpdateResponse> {
            .put(path, body: body)
        }

        /// Delete List
        ///
        /// Delete a List that you own.
        public var delete: Request<TwitterAPI.ListDeleteResponse> {
            .delete(path)
        }
    }
}

extension Paths.Lists.WithID {
    public var followers: Followers {
        Followers(path: path + "/followers")
    }

    public struct Followers {
        /// Path: `/2/lists/{id}/followers`
        public let path: String

        /// Returns User objects that follow a List by the provided List ID
        ///
        /// Returns a list of Users that follow a List by the provided List ID
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.Get2ListsIDFollowersResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var maxResults: Int?
            /// A 'long' pagination token.
            public var paginationToken: String?
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?
            /// The list of fields you can expand for a [User](#User) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["pinned_tweet_id"]
            public var expansions: [Expansions]?
            /// The fields available for a Tweet object.
            ///
            /// Example: ["attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"]
            public var tweetFields: [TweetFields]?

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public enum Expansions: String, Codable, CaseIterable {
                case pinnedTweetID = "pinned_tweet_id"
            }

            public enum TweetFields: String, Codable, CaseIterable {
                case attachments
                case authorID = "author_id"
                case contextAnnotations = "context_annotations"
                case conversationID = "conversation_id"
                case createdAt = "created_at"
                case entities
                case geo
                case id
                case inReplyToUserID = "in_reply_to_user_id"
                case lang
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case possiblySensitive = "possibly_sensitive"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case referencedTweets = "referenced_tweets"
                case replySettings = "reply_settings"
                case source
                case text
                case withheld
            }

            public init(maxResults: Int? = nil, paginationToken: String? = nil, userFields: [UserFields]? = nil, expansions: [Expansions]? = nil, tweetFields: [TweetFields]? = nil) {
                self.maxResults = maxResults
                self.paginationToken = paginationToken
                self.userFields = userFields
                self.expansions = expansions
                self.tweetFields = tweetFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(maxResults, forKey: "max_results")
                encoder.encode(paginationToken, forKey: "pagination_token")
                encoder.encode(userFields, forKey: "user.fields")
                encoder.encode(expansions, forKey: "expansions")
                encoder.encode(tweetFields, forKey: "tweet.fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Lists.WithID {
    public var members: Members {
        Members(path: path + "/members")
    }

    public struct Members {
        /// Path: `/2/lists/{id}/members`
        public let path: String

        /// Returns User objects that are members of a List by the provided List ID.
        ///
        /// Returns a list of Users that are members of a List by the provided List ID.
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.Get2ListsIDMembersResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var maxResults: Int?
            /// A 'long' pagination token.
            public var paginationToken: String?
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?
            /// The list of fields you can expand for a [User](#User) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["pinned_tweet_id"]
            public var expansions: [Expansions]?
            /// The fields available for a Tweet object.
            ///
            /// Example: ["attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"]
            public var tweetFields: [TweetFields]?

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public enum Expansions: String, Codable, CaseIterable {
                case pinnedTweetID = "pinned_tweet_id"
            }

            public enum TweetFields: String, Codable, CaseIterable {
                case attachments
                case authorID = "author_id"
                case contextAnnotations = "context_annotations"
                case conversationID = "conversation_id"
                case createdAt = "created_at"
                case entities
                case geo
                case id
                case inReplyToUserID = "in_reply_to_user_id"
                case lang
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case possiblySensitive = "possibly_sensitive"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case referencedTweets = "referenced_tweets"
                case replySettings = "reply_settings"
                case source
                case text
                case withheld
            }

            public init(maxResults: Int? = nil, paginationToken: String? = nil, userFields: [UserFields]? = nil, expansions: [Expansions]? = nil, tweetFields: [TweetFields]? = nil) {
                self.maxResults = maxResults
                self.paginationToken = paginationToken
                self.userFields = userFields
                self.expansions = expansions
                self.tweetFields = tweetFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(maxResults, forKey: "max_results")
                encoder.encode(paginationToken, forKey: "pagination_token")
                encoder.encode(userFields, forKey: "user.fields")
                encoder.encode(expansions, forKey: "expansions")
                encoder.encode(tweetFields, forKey: "tweet.fields")
                return encoder.items
            }
        }

        /// Add a List member
        ///
        /// Causes a User to become a member of a List.
        public func post(_ body: TwitterAPI.ListAddUserRequest? = nil) -> Request<TwitterAPI.ListMutateResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.Lists.WithID.Members {
    public func userID(_ userID: String) -> WithUserID {
        WithUserID(path: "\(path)/\(userID)")
    }

    public struct WithUserID {
        /// Path: `/2/lists/{id}/members/{user_id}`
        public let path: String

        /// Remove a List member
        ///
        /// Causes a User to be removed from the members of a List.
        public var delete: Request<TwitterAPI.ListMutateResponse> {
            .delete(path)
        }
    }
}

extension Paths.Lists.WithID {
    public var tweets: Tweets {
        Tweets(path: path + "/tweets")
    }

    public struct Tweets {
        /// Path: `/2/lists/{id}/tweets`
        public let path: String

        /// List Tweets timeline by List ID.
        ///
        /// Returns a list of Tweets associated with the provided List ID.
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.Get2ListsIDTweetsResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var maxResults: Int?
            /// A base36 pagination token.
            public var paginationToken: String?
            /// The fields available for a Tweet object.
            ///
            /// Example: ["attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"]
            public var tweetFields: [TweetFields]?
            /// The list of fields you can expand for a [Tweet](#Tweet) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["attachments.media_keys", "attachments.poll_ids", "author_id", "entities.mentions.username", "geo.place_id", "in_reply_to_user_id", "referenced_tweets.id", "referenced_tweets.id.author_id"]
            public var expansions: [Expansions]?
            /// The fields available for a Media object.
            ///
            /// Example: ["alt_text", "duration_ms", "height", "media_key", "non_public_metrics", "organic_metrics", "preview_image_url", "promoted_metrics", "public_metrics", "type", "url", "variants", "width"]
            public var mediaFields: [MediaFields]?
            /// The fields available for a Poll object.
            ///
            /// Example: ["duration_minutes", "end_datetime", "id", "options", "voting_status"]
            public var pollFields: [PollFields]?
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?
            /// The fields available for a Place object.
            ///
            /// Example: ["contained_within", "country", "country_code", "full_name", "geo", "id", "name", "place_type"]
            public var placeFields: [PlaceFields]?

            public enum TweetFields: String, Codable, CaseIterable {
                case attachments
                case authorID = "author_id"
                case contextAnnotations = "context_annotations"
                case conversationID = "conversation_id"
                case createdAt = "created_at"
                case entities
                case geo
                case id
                case inReplyToUserID = "in_reply_to_user_id"
                case lang
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case possiblySensitive = "possibly_sensitive"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case referencedTweets = "referenced_tweets"
                case replySettings = "reply_settings"
                case source
                case text
                case withheld
            }

            public enum Expansions: String, Codable, CaseIterable {
                case attachmentsMediaKeys = "attachments.media_keys"
                case attachmentsPollIDs = "attachments.poll_ids"
                case authorID = "author_id"
                case entitiesMentionsUsername = "entities.mentions.username"
                case geoPlaceID = "geo.place_id"
                case inReplyToUserID = "in_reply_to_user_id"
                case referencedTweetsID = "referenced_tweets.id"
                case referencedTweetsIDAuthorId = "referenced_tweets.id.author_id"
            }

            public enum MediaFields: String, Codable, CaseIterable {
                case altText = "alt_text"
                case durationMs = "duration_ms"
                case height
                case mediaKey = "media_key"
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case previewImageURL = "preview_image_url"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case type
                case url
                case variants
                case width
            }

            public enum PollFields: String, Codable, CaseIterable {
                case durationMinutes = "duration_minutes"
                case endDatetime = "end_datetime"
                case id
                case options
                case votingStatus = "voting_status"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public enum PlaceFields: String, Codable, CaseIterable {
                case containedWithin = "contained_within"
                case country
                case countryCode = "country_code"
                case fullName = "full_name"
                case geo
                case id
                case name
                case placeType = "place_type"
            }

            public init(maxResults: Int? = nil, paginationToken: String? = nil, tweetFields: [TweetFields]? = nil, expansions: [Expansions]? = nil, mediaFields: [MediaFields]? = nil, pollFields: [PollFields]? = nil, userFields: [UserFields]? = nil, placeFields: [PlaceFields]? = nil) {
                self.maxResults = maxResults
                self.paginationToken = paginationToken
                self.tweetFields = tweetFields
                self.expansions = expansions
                self.mediaFields = mediaFields
                self.pollFields = pollFields
                self.userFields = userFields
                self.placeFields = placeFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(maxResults, forKey: "max_results")
                encoder.encode(paginationToken, forKey: "pagination_token")
                encoder.encode(tweetFields, forKey: "tweet.fields")
                encoder.encode(expansions, forKey: "expansions")
                encoder.encode(mediaFields, forKey: "media.fields")
                encoder.encode(pollFields, forKey: "poll.fields")
                encoder.encode(userFields, forKey: "user.fields")
                encoder.encode(placeFields, forKey: "place.fields")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var openapiJSON: OpenapiJSON {
        OpenapiJSON(path: "/2/openapi.json")
    }

    public struct OpenapiJSON {
        /// Path: `/2/openapi.json`
        public let path: String

        /// Returns the OpenAPI Specification document.
        ///
        /// Full OpenAPI Specification in JSON format. (See https://github.com/OAI/OpenAPI-Specification/blob/master/README.md)
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }
    }
}

extension Paths {
    public static var spaces: Spaces {
        Spaces(path: "/2/spaces")
    }

    public struct Spaces {
        /// Path: `/2/spaces`
        public let path: String

        /// Space lookup up Space IDs
        ///
        /// Returns a variety of information about the Spaces specified by the requested IDs
        public func get(parameters: GetParameters) -> Request<TwitterAPI.Get2SpacesResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var ids: [String]
            /// The fields available for a Space object.
            ///
            /// Example: ["created_at", "creator_id", "ended_at", "host_ids", "id", "invited_user_ids", "is_ticketed", "lang", "participant_count", "scheduled_start", "speaker_ids", "started_at", "state", "subscriber_count", "title", "topic_ids", "updated_at"]
            public var spaceFields: [SpaceFields]?
            /// The list of fields you can expand for a [Space](#Space) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["creator_id", "host_ids", "invited_user_ids", "speaker_ids", "topic_ids"]
            public var expansions: [Expansions]?
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?
            /// The fields available for a Topic object.
            ///
            /// Example: ["description", "id", "name"]
            public var topicFields: [TopicFields]?

            public enum SpaceFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case creatorID = "creator_id"
                case endedAt = "ended_at"
                case hostIDs = "host_ids"
                case id
                case invitedUserIDs = "invited_user_ids"
                case isTicketed = "is_ticketed"
                case lang
                case participantCount = "participant_count"
                case scheduledStart = "scheduled_start"
                case speakerIDs = "speaker_ids"
                case startedAt = "started_at"
                case state
                case subscriberCount = "subscriber_count"
                case title
                case topicIDs = "topic_ids"
                case updatedAt = "updated_at"
            }

            public enum Expansions: String, Codable, CaseIterable {
                case creatorID = "creator_id"
                case hostIDs = "host_ids"
                case invitedUserIDs = "invited_user_ids"
                case speakerIDs = "speaker_ids"
                case topicIDs = "topic_ids"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public enum TopicFields: String, Codable, CaseIterable {
                case description
                case id
                case name
            }

            public init(ids: [String], spaceFields: [SpaceFields]? = nil, expansions: [Expansions]? = nil, userFields: [UserFields]? = nil, topicFields: [TopicFields]? = nil) {
                self.ids = ids
                self.spaceFields = spaceFields
                self.expansions = expansions
                self.userFields = userFields
                self.topicFields = topicFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(ids, forKey: "ids")
                encoder.encode(spaceFields, forKey: "space.fields", explode: false)
                encoder.encode(expansions, forKey: "expansions", explode: false)
                encoder.encode(userFields, forKey: "user.fields", explode: false)
                encoder.encode(topicFields, forKey: "topic.fields", explode: false)
                return encoder.items
            }
        }
    }
}

extension Paths.Spaces {
    public var by: By {
        By(path: path + "/by")
    }

    public struct By {
        /// Path: `/2/spaces/by`
        public let path: String
    }
}

extension Paths.Spaces.By {
    public var creatorIDs: CreatorIDs {
        CreatorIDs(path: path + "/creator_ids")
    }

    public struct CreatorIDs {
        /// Path: `/2/spaces/by/creator_ids`
        public let path: String

        /// Space lookup by their creators
        ///
        /// Returns a variety of information about the Spaces created by the provided User IDs
        public func get(parameters: GetParameters) -> Request<TwitterAPI.Get2SpacesByCreatorIDsResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var userIDs: [String]
            /// The fields available for a Space object.
            ///
            /// Example: ["created_at", "creator_id", "ended_at", "host_ids", "id", "invited_user_ids", "is_ticketed", "lang", "participant_count", "scheduled_start", "speaker_ids", "started_at", "state", "subscriber_count", "title", "topic_ids", "updated_at"]
            public var spaceFields: [SpaceFields]?
            /// The list of fields you can expand for a [Space](#Space) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["creator_id", "host_ids", "invited_user_ids", "speaker_ids", "topic_ids"]
            public var expansions: [Expansions]?
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?
            /// The fields available for a Topic object.
            ///
            /// Example: ["description", "id", "name"]
            public var topicFields: [TopicFields]?

            public enum SpaceFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case creatorID = "creator_id"
                case endedAt = "ended_at"
                case hostIDs = "host_ids"
                case id
                case invitedUserIDs = "invited_user_ids"
                case isTicketed = "is_ticketed"
                case lang
                case participantCount = "participant_count"
                case scheduledStart = "scheduled_start"
                case speakerIDs = "speaker_ids"
                case startedAt = "started_at"
                case state
                case subscriberCount = "subscriber_count"
                case title
                case topicIDs = "topic_ids"
                case updatedAt = "updated_at"
            }

            public enum Expansions: String, Codable, CaseIterable {
                case creatorID = "creator_id"
                case hostIDs = "host_ids"
                case invitedUserIDs = "invited_user_ids"
                case speakerIDs = "speaker_ids"
                case topicIDs = "topic_ids"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public enum TopicFields: String, Codable, CaseIterable {
                case description
                case id
                case name
            }

            public init(userIDs: [String], spaceFields: [SpaceFields]? = nil, expansions: [Expansions]? = nil, userFields: [UserFields]? = nil, topicFields: [TopicFields]? = nil) {
                self.userIDs = userIDs
                self.spaceFields = spaceFields
                self.expansions = expansions
                self.userFields = userFields
                self.topicFields = topicFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(userIDs, forKey: "user_ids")
                encoder.encode(spaceFields, forKey: "space.fields", explode: false)
                encoder.encode(expansions, forKey: "expansions", explode: false)
                encoder.encode(userFields, forKey: "user.fields", explode: false)
                encoder.encode(topicFields, forKey: "topic.fields", explode: false)
                return encoder.items
            }
        }
    }
}

extension Paths.Spaces {
    public var search: Search {
        Search(path: path + "/search")
    }

    public struct Search {
        /// Path: `/2/spaces/search`
        public let path: String

        /// Search for Spaces
        ///
        /// Returns Spaces that match the provided query.
        public func get(parameters: GetParameters) -> Request<TwitterAPI.Get2SpacesSearchResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            /// Example: "crypto"
            public var query: String
            public var state: State?
            public var maxResults: Int?
            /// The fields available for a Space object.
            ///
            /// Example: ["created_at", "creator_id", "ended_at", "host_ids", "id", "invited_user_ids", "is_ticketed", "lang", "participant_count", "scheduled_start", "speaker_ids", "started_at", "state", "subscriber_count", "title", "topic_ids", "updated_at"]
            public var spaceFields: [SpaceFields]?
            /// The list of fields you can expand for a [Space](#Space) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["creator_id", "host_ids", "invited_user_ids", "speaker_ids", "topic_ids"]
            public var expansions: [Expansions]?
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?
            /// The fields available for a Topic object.
            ///
            /// Example: ["description", "id", "name"]
            public var topicFields: [TopicFields]?

            public enum State: String, Codable, CaseIterable {
                case live
                case scheduled
                case all
            }

            public enum SpaceFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case creatorID = "creator_id"
                case endedAt = "ended_at"
                case hostIDs = "host_ids"
                case id
                case invitedUserIDs = "invited_user_ids"
                case isTicketed = "is_ticketed"
                case lang
                case participantCount = "participant_count"
                case scheduledStart = "scheduled_start"
                case speakerIDs = "speaker_ids"
                case startedAt = "started_at"
                case state
                case subscriberCount = "subscriber_count"
                case title
                case topicIDs = "topic_ids"
                case updatedAt = "updated_at"
            }

            public enum Expansions: String, Codable, CaseIterable {
                case creatorID = "creator_id"
                case hostIDs = "host_ids"
                case invitedUserIDs = "invited_user_ids"
                case speakerIDs = "speaker_ids"
                case topicIDs = "topic_ids"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public enum TopicFields: String, Codable, CaseIterable {
                case description
                case id
                case name
            }

            public init(query: String, state: State? = nil, maxResults: Int? = nil, spaceFields: [SpaceFields]? = nil, expansions: [Expansions]? = nil, userFields: [UserFields]? = nil, topicFields: [TopicFields]? = nil) {
                self.query = query
                self.state = state
                self.maxResults = maxResults
                self.spaceFields = spaceFields
                self.expansions = expansions
                self.userFields = userFields
                self.topicFields = topicFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(query, forKey: "query")
                encoder.encode(state, forKey: "state")
                encoder.encode(maxResults, forKey: "max_results")
                encoder.encode(spaceFields, forKey: "space.fields", explode: false)
                encoder.encode(expansions, forKey: "expansions", explode: false)
                encoder.encode(userFields, forKey: "user.fields", explode: false)
                encoder.encode(topicFields, forKey: "topic.fields", explode: false)
                return encoder.items
            }
        }
    }
}

extension Paths.Spaces {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/2/spaces/{id}`
        public let path: String

        /// Space lookup by Space ID
        ///
        /// Returns a variety of information about the Space specified by the requested ID
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.Get2SpacesIDResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// The fields available for a Space object.
            ///
            /// Example: ["created_at", "creator_id", "ended_at", "host_ids", "id", "invited_user_ids", "is_ticketed", "lang", "participant_count", "scheduled_start", "speaker_ids", "started_at", "state", "subscriber_count", "title", "topic_ids", "updated_at"]
            public var spaceFields: [SpaceFields]?
            /// The list of fields you can expand for a [Space](#Space) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["creator_id", "host_ids", "invited_user_ids", "speaker_ids", "topic_ids"]
            public var expansions: [Expansions]?
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?
            /// The fields available for a Topic object.
            ///
            /// Example: ["description", "id", "name"]
            public var topicFields: [TopicFields]?

            public enum SpaceFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case creatorID = "creator_id"
                case endedAt = "ended_at"
                case hostIDs = "host_ids"
                case id
                case invitedUserIDs = "invited_user_ids"
                case isTicketed = "is_ticketed"
                case lang
                case participantCount = "participant_count"
                case scheduledStart = "scheduled_start"
                case speakerIDs = "speaker_ids"
                case startedAt = "started_at"
                case state
                case subscriberCount = "subscriber_count"
                case title
                case topicIDs = "topic_ids"
                case updatedAt = "updated_at"
            }

            public enum Expansions: String, Codable, CaseIterable {
                case creatorID = "creator_id"
                case hostIDs = "host_ids"
                case invitedUserIDs = "invited_user_ids"
                case speakerIDs = "speaker_ids"
                case topicIDs = "topic_ids"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public enum TopicFields: String, Codable, CaseIterable {
                case description
                case id
                case name
            }

            public init(spaceFields: [SpaceFields]? = nil, expansions: [Expansions]? = nil, userFields: [UserFields]? = nil, topicFields: [TopicFields]? = nil) {
                self.spaceFields = spaceFields
                self.expansions = expansions
                self.userFields = userFields
                self.topicFields = topicFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(spaceFields, forKey: "space.fields")
                encoder.encode(expansions, forKey: "expansions")
                encoder.encode(userFields, forKey: "user.fields")
                encoder.encode(topicFields, forKey: "topic.fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Spaces.WithID {
    public var buyers: Buyers {
        Buyers(path: path + "/buyers")
    }

    public struct Buyers {
        /// Path: `/2/spaces/{id}/buyers`
        public let path: String

        /// Retrieve the list of Users who purchased a ticket to the given space
        ///
        /// Retrieves the list of Users who purchased a ticket to the given space
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.Get2SpacesIDBuyersResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// A base32 pagination token.
            public var paginationToken: String?
            public var maxResults: Int?
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?
            /// The list of fields you can expand for a [User](#User) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["pinned_tweet_id"]
            public var expansions: [Expansions]?
            /// The fields available for a Tweet object.
            ///
            /// Example: ["attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"]
            public var tweetFields: [TweetFields]?

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public enum Expansions: String, Codable, CaseIterable {
                case pinnedTweetID = "pinned_tweet_id"
            }

            public enum TweetFields: String, Codable, CaseIterable {
                case attachments
                case authorID = "author_id"
                case contextAnnotations = "context_annotations"
                case conversationID = "conversation_id"
                case createdAt = "created_at"
                case entities
                case geo
                case id
                case inReplyToUserID = "in_reply_to_user_id"
                case lang
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case possiblySensitive = "possibly_sensitive"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case referencedTweets = "referenced_tweets"
                case replySettings = "reply_settings"
                case source
                case text
                case withheld
            }

            public init(paginationToken: String? = nil, maxResults: Int? = nil, userFields: [UserFields]? = nil, expansions: [Expansions]? = nil, tweetFields: [TweetFields]? = nil) {
                self.paginationToken = paginationToken
                self.maxResults = maxResults
                self.userFields = userFields
                self.expansions = expansions
                self.tweetFields = tweetFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(paginationToken, forKey: "pagination_token")
                encoder.encode(maxResults, forKey: "max_results")
                encoder.encode(userFields, forKey: "user.fields")
                encoder.encode(expansions, forKey: "expansions")
                encoder.encode(tweetFields, forKey: "tweet.fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Spaces.WithID {
    public var tweets: Tweets {
        Tweets(path: path + "/tweets")
    }

    public struct Tweets {
        /// Path: `/2/spaces/{id}/tweets`
        public let path: String

        /// Retrieve Tweets from a Space.
        ///
        /// Retrieves Tweets shared in the specified Space.
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.Get2SpacesIDTweetsResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Example: 25
            public var maxResults: Int?
            /// The fields available for a Tweet object.
            ///
            /// Example: ["attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"]
            public var tweetFields: [TweetFields]?
            /// The list of fields you can expand for a [Tweet](#Tweet) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["attachments.media_keys", "attachments.poll_ids", "author_id", "entities.mentions.username", "geo.place_id", "in_reply_to_user_id", "referenced_tweets.id", "referenced_tweets.id.author_id"]
            public var expansions: [Expansions]?
            /// The fields available for a Media object.
            ///
            /// Example: ["alt_text", "duration_ms", "height", "media_key", "non_public_metrics", "organic_metrics", "preview_image_url", "promoted_metrics", "public_metrics", "type", "url", "variants", "width"]
            public var mediaFields: [MediaFields]?
            /// The fields available for a Poll object.
            ///
            /// Example: ["duration_minutes", "end_datetime", "id", "options", "voting_status"]
            public var pollFields: [PollFields]?
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?
            /// The fields available for a Place object.
            ///
            /// Example: ["contained_within", "country", "country_code", "full_name", "geo", "id", "name", "place_type"]
            public var placeFields: [PlaceFields]?

            public enum TweetFields: String, Codable, CaseIterable {
                case attachments
                case authorID = "author_id"
                case contextAnnotations = "context_annotations"
                case conversationID = "conversation_id"
                case createdAt = "created_at"
                case entities
                case geo
                case id
                case inReplyToUserID = "in_reply_to_user_id"
                case lang
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case possiblySensitive = "possibly_sensitive"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case referencedTweets = "referenced_tweets"
                case replySettings = "reply_settings"
                case source
                case text
                case withheld
            }

            public enum Expansions: String, Codable, CaseIterable {
                case attachmentsMediaKeys = "attachments.media_keys"
                case attachmentsPollIDs = "attachments.poll_ids"
                case authorID = "author_id"
                case entitiesMentionsUsername = "entities.mentions.username"
                case geoPlaceID = "geo.place_id"
                case inReplyToUserID = "in_reply_to_user_id"
                case referencedTweetsID = "referenced_tweets.id"
                case referencedTweetsIDAuthorId = "referenced_tweets.id.author_id"
            }

            public enum MediaFields: String, Codable, CaseIterable {
                case altText = "alt_text"
                case durationMs = "duration_ms"
                case height
                case mediaKey = "media_key"
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case previewImageURL = "preview_image_url"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case type
                case url
                case variants
                case width
            }

            public enum PollFields: String, Codable, CaseIterable {
                case durationMinutes = "duration_minutes"
                case endDatetime = "end_datetime"
                case id
                case options
                case votingStatus = "voting_status"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public enum PlaceFields: String, Codable, CaseIterable {
                case containedWithin = "contained_within"
                case country
                case countryCode = "country_code"
                case fullName = "full_name"
                case geo
                case id
                case name
                case placeType = "place_type"
            }

            public init(maxResults: Int? = nil, tweetFields: [TweetFields]? = nil, expansions: [Expansions]? = nil, mediaFields: [MediaFields]? = nil, pollFields: [PollFields]? = nil, userFields: [UserFields]? = nil, placeFields: [PlaceFields]? = nil) {
                self.maxResults = maxResults
                self.tweetFields = tweetFields
                self.expansions = expansions
                self.mediaFields = mediaFields
                self.pollFields = pollFields
                self.userFields = userFields
                self.placeFields = placeFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(maxResults, forKey: "max_results")
                encoder.encode(tweetFields, forKey: "tweet.fields")
                encoder.encode(expansions, forKey: "expansions")
                encoder.encode(mediaFields, forKey: "media.fields")
                encoder.encode(pollFields, forKey: "poll.fields")
                encoder.encode(userFields, forKey: "user.fields")
                encoder.encode(placeFields, forKey: "place.fields")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var tweets: Tweets {
        Tweets(path: "/2/tweets")
    }

    public struct Tweets {
        /// Path: `/2/tweets`
        public let path: String

        /// Tweet lookup by Tweet IDs
        ///
        /// Returns a variety of information about the Tweet specified by the requested ID.
        public func get(parameters: GetParameters) -> Request<TwitterAPI.Get2TweetsResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var ids: [String]
            /// The fields available for a Tweet object.
            ///
            /// Example: ["attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"]
            public var tweetFields: [TweetFields]?
            /// The list of fields you can expand for a [Tweet](#Tweet) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["attachments.media_keys", "attachments.poll_ids", "author_id", "entities.mentions.username", "geo.place_id", "in_reply_to_user_id", "referenced_tweets.id", "referenced_tweets.id.author_id"]
            public var expansions: [Expansions]?
            /// The fields available for a Media object.
            ///
            /// Example: ["alt_text", "duration_ms", "height", "media_key", "non_public_metrics", "organic_metrics", "preview_image_url", "promoted_metrics", "public_metrics", "type", "url", "variants", "width"]
            public var mediaFields: [MediaFields]?
            /// The fields available for a Poll object.
            ///
            /// Example: ["duration_minutes", "end_datetime", "id", "options", "voting_status"]
            public var pollFields: [PollFields]?
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?
            /// The fields available for a Place object.
            ///
            /// Example: ["contained_within", "country", "country_code", "full_name", "geo", "id", "name", "place_type"]
            public var placeFields: [PlaceFields]?

            public enum TweetFields: String, Codable, CaseIterable {
                case attachments
                case authorID = "author_id"
                case contextAnnotations = "context_annotations"
                case conversationID = "conversation_id"
                case createdAt = "created_at"
                case entities
                case geo
                case id
                case inReplyToUserID = "in_reply_to_user_id"
                case lang
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case possiblySensitive = "possibly_sensitive"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case referencedTweets = "referenced_tweets"
                case replySettings = "reply_settings"
                case source
                case text
                case withheld
            }

            public enum Expansions: String, Codable, CaseIterable {
                case attachmentsMediaKeys = "attachments.media_keys"
                case attachmentsPollIDs = "attachments.poll_ids"
                case authorID = "author_id"
                case entitiesMentionsUsername = "entities.mentions.username"
                case geoPlaceID = "geo.place_id"
                case inReplyToUserID = "in_reply_to_user_id"
                case referencedTweetsID = "referenced_tweets.id"
                case referencedTweetsIDAuthorId = "referenced_tweets.id.author_id"
            }

            public enum MediaFields: String, Codable, CaseIterable {
                case altText = "alt_text"
                case durationMs = "duration_ms"
                case height
                case mediaKey = "media_key"
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case previewImageURL = "preview_image_url"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case type
                case url
                case variants
                case width
            }

            public enum PollFields: String, Codable, CaseIterable {
                case durationMinutes = "duration_minutes"
                case endDatetime = "end_datetime"
                case id
                case options
                case votingStatus = "voting_status"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public enum PlaceFields: String, Codable, CaseIterable {
                case containedWithin = "contained_within"
                case country
                case countryCode = "country_code"
                case fullName = "full_name"
                case geo
                case id
                case name
                case placeType = "place_type"
            }

            public init(ids: [String], tweetFields: [TweetFields]? = nil, expansions: [Expansions]? = nil, mediaFields: [MediaFields]? = nil, pollFields: [PollFields]? = nil, userFields: [UserFields]? = nil, placeFields: [PlaceFields]? = nil) {
                self.ids = ids
                self.tweetFields = tweetFields
                self.expansions = expansions
                self.mediaFields = mediaFields
                self.pollFields = pollFields
                self.userFields = userFields
                self.placeFields = placeFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(ids, forKey: "ids")
                encoder.encode(tweetFields, forKey: "tweet.fields")
                encoder.encode(expansions, forKey: "expansions")
                encoder.encode(mediaFields, forKey: "media.fields")
                encoder.encode(pollFields, forKey: "poll.fields")
                encoder.encode(userFields, forKey: "user.fields")
                encoder.encode(placeFields, forKey: "place.fields")
                return encoder.items
            }
        }

        /// Creation of a Tweet
        ///
        /// Causes the User to create a Tweet under the authorized account.
        public func post(_ body: TwitterAPI.TweetCreateRequest) -> Request<TwitterAPI.TweetCreateResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.Tweets {
    public var compliance: Compliance {
        Compliance(path: path + "/compliance")
    }

    public struct Compliance {
        /// Path: `/2/tweets/compliance`
        public let path: String
    }
}

extension Paths.Tweets.Compliance {
    public var stream: Stream {
        Stream(path: path + "/stream")
    }

    public struct Stream {
        /// Path: `/2/tweets/compliance/stream`
        public let path: String

        /// Tweets Compliance stream
        ///
        /// Streams 100% of compliance data for Tweets
        public func get(parameters: GetParameters) -> Request<TwitterAPI.TweetComplianceStreamResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var backfillMinutes: Int?
            public var partition: Int
            public var startTime: Date?
            public var endTime: Date?

            public init(backfillMinutes: Int? = nil, partition: Int, startTime: Date? = nil, endTime: Date? = nil) {
                self.backfillMinutes = backfillMinutes
                self.partition = partition
                self.startTime = startTime
                self.endTime = endTime
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(backfillMinutes, forKey: "backfill_minutes")
                encoder.encode(partition, forKey: "partition")
                encoder.encode(startTime, forKey: "start_time")
                encoder.encode(endTime, forKey: "end_time")
                return encoder.items
            }
        }
    }
}

extension Paths.Tweets {
    public var counts: Counts {
        Counts(path: path + "/counts")
    }

    public struct Counts {
        /// Path: `/2/tweets/counts`
        public let path: String
    }
}

extension Paths.Tweets.Counts {
    public var all: All {
        All(path: path + "/all")
    }

    public struct All {
        /// Path: `/2/tweets/counts/all`
        public let path: String

        /// Full archive search counts
        ///
        /// Returns Tweet Counts that match a search query.
        public func get(parameters: GetParameters) -> Request<TwitterAPI.Get2TweetsCountsAllResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            /// Example: "(from:TwitterDev OR from:TwitterAPI) has:media -is:retweet"
            public var query: String
            public var startTime: Date?
            public var endTime: Date?
            /// Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
            ///
            /// Example: "1346889436626259968"
            public var sinceID: String?
            /// Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
            ///
            /// Example: "1346889436626259968"
            public var untilID: String?
            /// A base36 pagination token.
            public var nextToken: String?
            /// A base36 pagination token.
            public var paginationToken: String?
            public var granularity: Granularity?
            /// The fields available for a SearchCount object.
            ///
            /// Example: ["end", "start", "tweet_count"]
            public var searchCountFields: [SearchCountFields]?

            public enum Granularity: String, Codable, CaseIterable {
                case minute
                case hour
                case day
            }

            public enum SearchCountFields: String, Codable, CaseIterable {
                case end
                case start
                case tweetCount = "tweet_count"
            }

            public init(query: String, startTime: Date? = nil, endTime: Date? = nil, sinceID: String? = nil, untilID: String? = nil, nextToken: String? = nil, paginationToken: String? = nil, granularity: Granularity? = nil, searchCountFields: [SearchCountFields]? = nil) {
                self.query = query
                self.startTime = startTime
                self.endTime = endTime
                self.sinceID = sinceID
                self.untilID = untilID
                self.nextToken = nextToken
                self.paginationToken = paginationToken
                self.granularity = granularity
                self.searchCountFields = searchCountFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(query, forKey: "query")
                encoder.encode(startTime, forKey: "start_time")
                encoder.encode(endTime, forKey: "end_time")
                encoder.encode(sinceID, forKey: "since_id")
                encoder.encode(untilID, forKey: "until_id")
                encoder.encode(nextToken, forKey: "next_token")
                encoder.encode(paginationToken, forKey: "pagination_token")
                encoder.encode(granularity, forKey: "granularity")
                encoder.encode(searchCountFields, forKey: "search_count.fields", explode: false)
                return encoder.items
            }
        }
    }
}

extension Paths.Tweets.Counts {
    public var recent: Recent {
        Recent(path: path + "/recent")
    }

    public struct Recent {
        /// Path: `/2/tweets/counts/recent`
        public let path: String

        /// Recent search counts
        ///
        /// Returns Tweet Counts from the last 7 days that match a search query.
        public func get(parameters: GetParameters) -> Request<TwitterAPI.Get2TweetsCountsRecentResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            /// Example: "(from:TwitterDev OR from:TwitterAPI) has:media -is:retweet"
            public var query: String
            public var startTime: Date?
            public var endTime: Date?
            /// Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
            ///
            /// Example: "1346889436626259968"
            public var sinceID: String?
            /// Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
            ///
            /// Example: "1346889436626259968"
            public var untilID: String?
            /// A base36 pagination token.
            public var nextToken: String?
            /// A base36 pagination token.
            public var paginationToken: String?
            public var granularity: Granularity?
            /// The fields available for a SearchCount object.
            ///
            /// Example: ["end", "start", "tweet_count"]
            public var searchCountFields: [SearchCountFields]?

            public enum Granularity: String, Codable, CaseIterable {
                case minute
                case hour
                case day
            }

            public enum SearchCountFields: String, Codable, CaseIterable {
                case end
                case start
                case tweetCount = "tweet_count"
            }

            public init(query: String, startTime: Date? = nil, endTime: Date? = nil, sinceID: String? = nil, untilID: String? = nil, nextToken: String? = nil, paginationToken: String? = nil, granularity: Granularity? = nil, searchCountFields: [SearchCountFields]? = nil) {
                self.query = query
                self.startTime = startTime
                self.endTime = endTime
                self.sinceID = sinceID
                self.untilID = untilID
                self.nextToken = nextToken
                self.paginationToken = paginationToken
                self.granularity = granularity
                self.searchCountFields = searchCountFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(query, forKey: "query")
                encoder.encode(startTime, forKey: "start_time")
                encoder.encode(endTime, forKey: "end_time")
                encoder.encode(sinceID, forKey: "since_id")
                encoder.encode(untilID, forKey: "until_id")
                encoder.encode(nextToken, forKey: "next_token")
                encoder.encode(paginationToken, forKey: "pagination_token")
                encoder.encode(granularity, forKey: "granularity")
                encoder.encode(searchCountFields, forKey: "search_count.fields", explode: false)
                return encoder.items
            }
        }
    }
}

extension Paths.Tweets {
    public var firehose: Firehose {
        Firehose(path: path + "/firehose")
    }

    public struct Firehose {
        /// Path: `/2/tweets/firehose`
        public let path: String
    }
}

extension Paths.Tweets.Firehose {
    public var stream: Stream {
        Stream(path: path + "/stream")
    }

    public struct Stream {
        /// Path: `/2/tweets/firehose/stream`
        public let path: String

        /// Firehose stream
        ///
        /// Streams 100% of public Tweets.
        public func get(parameters: GetParameters) -> Request<TwitterAPI.StreamingTweetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var backfillMinutes: Int?
            public var partition: Int
            public var startTime: Date?
            public var endTime: Date?
            /// The fields available for a Tweet object.
            ///
            /// Example: ["attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"]
            public var tweetFields: [TweetFields]?
            /// The list of fields you can expand for a [Tweet](#Tweet) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["attachments.media_keys", "attachments.poll_ids", "author_id", "entities.mentions.username", "geo.place_id", "in_reply_to_user_id", "referenced_tweets.id", "referenced_tweets.id.author_id"]
            public var expansions: [Expansions]?
            /// The fields available for a Media object.
            ///
            /// Example: ["alt_text", "duration_ms", "height", "media_key", "non_public_metrics", "organic_metrics", "preview_image_url", "promoted_metrics", "public_metrics", "type", "url", "variants", "width"]
            public var mediaFields: [MediaFields]?
            /// The fields available for a Poll object.
            ///
            /// Example: ["duration_minutes", "end_datetime", "id", "options", "voting_status"]
            public var pollFields: [PollFields]?
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?
            /// The fields available for a Place object.
            ///
            /// Example: ["contained_within", "country", "country_code", "full_name", "geo", "id", "name", "place_type"]
            public var placeFields: [PlaceFields]?

            public enum TweetFields: String, Codable, CaseIterable {
                case attachments
                case authorID = "author_id"
                case contextAnnotations = "context_annotations"
                case conversationID = "conversation_id"
                case createdAt = "created_at"
                case entities
                case geo
                case id
                case inReplyToUserID = "in_reply_to_user_id"
                case lang
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case possiblySensitive = "possibly_sensitive"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case referencedTweets = "referenced_tweets"
                case replySettings = "reply_settings"
                case source
                case text
                case withheld
            }

            public enum Expansions: String, Codable, CaseIterable {
                case attachmentsMediaKeys = "attachments.media_keys"
                case attachmentsPollIDs = "attachments.poll_ids"
                case authorID = "author_id"
                case entitiesMentionsUsername = "entities.mentions.username"
                case geoPlaceID = "geo.place_id"
                case inReplyToUserID = "in_reply_to_user_id"
                case referencedTweetsID = "referenced_tweets.id"
                case referencedTweetsIDAuthorId = "referenced_tweets.id.author_id"
            }

            public enum MediaFields: String, Codable, CaseIterable {
                case altText = "alt_text"
                case durationMs = "duration_ms"
                case height
                case mediaKey = "media_key"
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case previewImageURL = "preview_image_url"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case type
                case url
                case variants
                case width
            }

            public enum PollFields: String, Codable, CaseIterable {
                case durationMinutes = "duration_minutes"
                case endDatetime = "end_datetime"
                case id
                case options
                case votingStatus = "voting_status"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public enum PlaceFields: String, Codable, CaseIterable {
                case containedWithin = "contained_within"
                case country
                case countryCode = "country_code"
                case fullName = "full_name"
                case geo
                case id
                case name
                case placeType = "place_type"
            }

            public init(backfillMinutes: Int? = nil, partition: Int, startTime: Date? = nil, endTime: Date? = nil, tweetFields: [TweetFields]? = nil, expansions: [Expansions]? = nil, mediaFields: [MediaFields]? = nil, pollFields: [PollFields]? = nil, userFields: [UserFields]? = nil, placeFields: [PlaceFields]? = nil) {
                self.backfillMinutes = backfillMinutes
                self.partition = partition
                self.startTime = startTime
                self.endTime = endTime
                self.tweetFields = tweetFields
                self.expansions = expansions
                self.mediaFields = mediaFields
                self.pollFields = pollFields
                self.userFields = userFields
                self.placeFields = placeFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(backfillMinutes, forKey: "backfill_minutes")
                encoder.encode(partition, forKey: "partition")
                encoder.encode(startTime, forKey: "start_time")
                encoder.encode(endTime, forKey: "end_time")
                encoder.encode(tweetFields, forKey: "tweet.fields")
                encoder.encode(expansions, forKey: "expansions")
                encoder.encode(mediaFields, forKey: "media.fields")
                encoder.encode(pollFields, forKey: "poll.fields")
                encoder.encode(userFields, forKey: "user.fields")
                encoder.encode(placeFields, forKey: "place.fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Tweets {
    public var sample: Sample {
        Sample(path: path + "/sample")
    }

    public struct Sample {
        /// Path: `/2/tweets/sample`
        public let path: String
    }
}

extension Paths.Tweets.Sample {
    public var stream: Stream {
        Stream(path: path + "/stream")
    }

    public struct Stream {
        /// Path: `/2/tweets/sample/stream`
        public let path: String

        /// Sample stream
        ///
        /// Streams a deterministic 1% of public Tweets.
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.StreamingTweetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var backfillMinutes: Int?
            /// The fields available for a Tweet object.
            ///
            /// Example: ["attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"]
            public var tweetFields: [TweetFields]?
            /// The list of fields you can expand for a [Tweet](#Tweet) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["attachments.media_keys", "attachments.poll_ids", "author_id", "entities.mentions.username", "geo.place_id", "in_reply_to_user_id", "referenced_tweets.id", "referenced_tweets.id.author_id"]
            public var expansions: [Expansions]?
            /// The fields available for a Media object.
            ///
            /// Example: ["alt_text", "duration_ms", "height", "media_key", "non_public_metrics", "organic_metrics", "preview_image_url", "promoted_metrics", "public_metrics", "type", "url", "variants", "width"]
            public var mediaFields: [MediaFields]?
            /// The fields available for a Poll object.
            ///
            /// Example: ["duration_minutes", "end_datetime", "id", "options", "voting_status"]
            public var pollFields: [PollFields]?
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?
            /// The fields available for a Place object.
            ///
            /// Example: ["contained_within", "country", "country_code", "full_name", "geo", "id", "name", "place_type"]
            public var placeFields: [PlaceFields]?

            public enum TweetFields: String, Codable, CaseIterable {
                case attachments
                case authorID = "author_id"
                case contextAnnotations = "context_annotations"
                case conversationID = "conversation_id"
                case createdAt = "created_at"
                case entities
                case geo
                case id
                case inReplyToUserID = "in_reply_to_user_id"
                case lang
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case possiblySensitive = "possibly_sensitive"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case referencedTweets = "referenced_tweets"
                case replySettings = "reply_settings"
                case source
                case text
                case withheld
            }

            public enum Expansions: String, Codable, CaseIterable {
                case attachmentsMediaKeys = "attachments.media_keys"
                case attachmentsPollIDs = "attachments.poll_ids"
                case authorID = "author_id"
                case entitiesMentionsUsername = "entities.mentions.username"
                case geoPlaceID = "geo.place_id"
                case inReplyToUserID = "in_reply_to_user_id"
                case referencedTweetsID = "referenced_tweets.id"
                case referencedTweetsIDAuthorId = "referenced_tweets.id.author_id"
            }

            public enum MediaFields: String, Codable, CaseIterable {
                case altText = "alt_text"
                case durationMs = "duration_ms"
                case height
                case mediaKey = "media_key"
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case previewImageURL = "preview_image_url"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case type
                case url
                case variants
                case width
            }

            public enum PollFields: String, Codable, CaseIterable {
                case durationMinutes = "duration_minutes"
                case endDatetime = "end_datetime"
                case id
                case options
                case votingStatus = "voting_status"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public enum PlaceFields: String, Codable, CaseIterable {
                case containedWithin = "contained_within"
                case country
                case countryCode = "country_code"
                case fullName = "full_name"
                case geo
                case id
                case name
                case placeType = "place_type"
            }

            public init(backfillMinutes: Int? = nil, tweetFields: [TweetFields]? = nil, expansions: [Expansions]? = nil, mediaFields: [MediaFields]? = nil, pollFields: [PollFields]? = nil, userFields: [UserFields]? = nil, placeFields: [PlaceFields]? = nil) {
                self.backfillMinutes = backfillMinutes
                self.tweetFields = tweetFields
                self.expansions = expansions
                self.mediaFields = mediaFields
                self.pollFields = pollFields
                self.userFields = userFields
                self.placeFields = placeFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(backfillMinutes, forKey: "backfill_minutes")
                encoder.encode(tweetFields, forKey: "tweet.fields")
                encoder.encode(expansions, forKey: "expansions")
                encoder.encode(mediaFields, forKey: "media.fields")
                encoder.encode(pollFields, forKey: "poll.fields")
                encoder.encode(userFields, forKey: "user.fields")
                encoder.encode(placeFields, forKey: "place.fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Tweets {
    public var sample10: Sample10 {
        Sample10(path: path + "/sample10")
    }

    public struct Sample10 {
        /// Path: `/2/tweets/sample10`
        public let path: String
    }
}

extension Paths.Tweets.Sample10 {
    public var stream: Stream {
        Stream(path: path + "/stream")
    }

    public struct Stream {
        /// Path: `/2/tweets/sample10/stream`
        public let path: String

        /// Sample 10% stream
        ///
        /// Streams a deterministic 10% of public Tweets.
        public func get(parameters: GetParameters) -> Request<TwitterAPI.Get2TweetsSample10StreamResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var backfillMinutes: Int?
            public var partition: Int
            public var startTime: Date?
            public var endTime: Date?
            /// The fields available for a Tweet object.
            ///
            /// Example: ["attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"]
            public var tweetFields: [TweetFields]?
            /// The list of fields you can expand for a [Tweet](#Tweet) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["attachments.media_keys", "attachments.poll_ids", "author_id", "entities.mentions.username", "geo.place_id", "in_reply_to_user_id", "referenced_tweets.id", "referenced_tweets.id.author_id"]
            public var expansions: [Expansions]?
            /// The fields available for a Media object.
            ///
            /// Example: ["alt_text", "duration_ms", "height", "media_key", "non_public_metrics", "organic_metrics", "preview_image_url", "promoted_metrics", "public_metrics", "type", "url", "variants", "width"]
            public var mediaFields: [MediaFields]?
            /// The fields available for a Poll object.
            ///
            /// Example: ["duration_minutes", "end_datetime", "id", "options", "voting_status"]
            public var pollFields: [PollFields]?
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?
            /// The fields available for a Place object.
            ///
            /// Example: ["contained_within", "country", "country_code", "full_name", "geo", "id", "name", "place_type"]
            public var placeFields: [PlaceFields]?

            public enum TweetFields: String, Codable, CaseIterable {
                case attachments
                case authorID = "author_id"
                case contextAnnotations = "context_annotations"
                case conversationID = "conversation_id"
                case createdAt = "created_at"
                case entities
                case geo
                case id
                case inReplyToUserID = "in_reply_to_user_id"
                case lang
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case possiblySensitive = "possibly_sensitive"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case referencedTweets = "referenced_tweets"
                case replySettings = "reply_settings"
                case source
                case text
                case withheld
            }

            public enum Expansions: String, Codable, CaseIterable {
                case attachmentsMediaKeys = "attachments.media_keys"
                case attachmentsPollIDs = "attachments.poll_ids"
                case authorID = "author_id"
                case entitiesMentionsUsername = "entities.mentions.username"
                case geoPlaceID = "geo.place_id"
                case inReplyToUserID = "in_reply_to_user_id"
                case referencedTweetsID = "referenced_tweets.id"
                case referencedTweetsIDAuthorId = "referenced_tweets.id.author_id"
            }

            public enum MediaFields: String, Codable, CaseIterable {
                case altText = "alt_text"
                case durationMs = "duration_ms"
                case height
                case mediaKey = "media_key"
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case previewImageURL = "preview_image_url"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case type
                case url
                case variants
                case width
            }

            public enum PollFields: String, Codable, CaseIterable {
                case durationMinutes = "duration_minutes"
                case endDatetime = "end_datetime"
                case id
                case options
                case votingStatus = "voting_status"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public enum PlaceFields: String, Codable, CaseIterable {
                case containedWithin = "contained_within"
                case country
                case countryCode = "country_code"
                case fullName = "full_name"
                case geo
                case id
                case name
                case placeType = "place_type"
            }

            public init(backfillMinutes: Int? = nil, partition: Int, startTime: Date? = nil, endTime: Date? = nil, tweetFields: [TweetFields]? = nil, expansions: [Expansions]? = nil, mediaFields: [MediaFields]? = nil, pollFields: [PollFields]? = nil, userFields: [UserFields]? = nil, placeFields: [PlaceFields]? = nil) {
                self.backfillMinutes = backfillMinutes
                self.partition = partition
                self.startTime = startTime
                self.endTime = endTime
                self.tweetFields = tweetFields
                self.expansions = expansions
                self.mediaFields = mediaFields
                self.pollFields = pollFields
                self.userFields = userFields
                self.placeFields = placeFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(backfillMinutes, forKey: "backfill_minutes")
                encoder.encode(partition, forKey: "partition")
                encoder.encode(startTime, forKey: "start_time")
                encoder.encode(endTime, forKey: "end_time")
                encoder.encode(tweetFields, forKey: "tweet.fields")
                encoder.encode(expansions, forKey: "expansions")
                encoder.encode(mediaFields, forKey: "media.fields")
                encoder.encode(pollFields, forKey: "poll.fields")
                encoder.encode(userFields, forKey: "user.fields")
                encoder.encode(placeFields, forKey: "place.fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Tweets {
    public var search: Search {
        Search(path: path + "/search")
    }

    public struct Search {
        /// Path: `/2/tweets/search`
        public let path: String
    }
}

extension Paths.Tweets.Search {
    public var all: All {
        All(path: path + "/all")
    }

    public struct All {
        /// Path: `/2/tweets/search/all`
        public let path: String

        /// Full-archive search
        ///
        /// Returns Tweets that match a search query.
        public func get(parameters: GetParameters) -> Request<TwitterAPI.Get2TweetsSearchAllResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            /// Example: "(from:TwitterDev OR from:TwitterAPI) has:media -is:retweet"
            public var query: String
            public var startTime: Date?
            public var endTime: Date?
            /// Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
            ///
            /// Example: "1346889436626259968"
            public var sinceID: String?
            /// Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
            ///
            /// Example: "1346889436626259968"
            public var untilID: String?
            public var maxResults: Int?
            /// A base36 pagination token.
            public var nextToken: String?
            /// A base36 pagination token.
            public var paginationToken: String?
            public var sortOrder: SortOrder?
            /// The fields available for a Tweet object.
            ///
            /// Example: ["attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"]
            public var tweetFields: [TweetFields]?
            /// The list of fields you can expand for a [Tweet](#Tweet) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["attachments.media_keys", "attachments.poll_ids", "author_id", "entities.mentions.username", "geo.place_id", "in_reply_to_user_id", "referenced_tweets.id", "referenced_tweets.id.author_id"]
            public var expansions: [Expansions]?
            /// The fields available for a Media object.
            ///
            /// Example: ["alt_text", "duration_ms", "height", "media_key", "non_public_metrics", "organic_metrics", "preview_image_url", "promoted_metrics", "public_metrics", "type", "url", "variants", "width"]
            public var mediaFields: [MediaFields]?
            /// The fields available for a Poll object.
            ///
            /// Example: ["duration_minutes", "end_datetime", "id", "options", "voting_status"]
            public var pollFields: [PollFields]?
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?
            /// The fields available for a Place object.
            ///
            /// Example: ["contained_within", "country", "country_code", "full_name", "geo", "id", "name", "place_type"]
            public var placeFields: [PlaceFields]?

            public enum SortOrder: String, Codable, CaseIterable {
                case recency
                case relevancy
            }

            public enum TweetFields: String, Codable, CaseIterable {
                case attachments
                case authorID = "author_id"
                case contextAnnotations = "context_annotations"
                case conversationID = "conversation_id"
                case createdAt = "created_at"
                case entities
                case geo
                case id
                case inReplyToUserID = "in_reply_to_user_id"
                case lang
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case possiblySensitive = "possibly_sensitive"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case referencedTweets = "referenced_tweets"
                case replySettings = "reply_settings"
                case source
                case text
                case withheld
            }

            public enum Expansions: String, Codable, CaseIterable {
                case attachmentsMediaKeys = "attachments.media_keys"
                case attachmentsPollIDs = "attachments.poll_ids"
                case authorID = "author_id"
                case entitiesMentionsUsername = "entities.mentions.username"
                case geoPlaceID = "geo.place_id"
                case inReplyToUserID = "in_reply_to_user_id"
                case referencedTweetsID = "referenced_tweets.id"
                case referencedTweetsIDAuthorId = "referenced_tweets.id.author_id"
            }

            public enum MediaFields: String, Codable, CaseIterable {
                case altText = "alt_text"
                case durationMs = "duration_ms"
                case height
                case mediaKey = "media_key"
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case previewImageURL = "preview_image_url"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case type
                case url
                case variants
                case width
            }

            public enum PollFields: String, Codable, CaseIterable {
                case durationMinutes = "duration_minutes"
                case endDatetime = "end_datetime"
                case id
                case options
                case votingStatus = "voting_status"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public enum PlaceFields: String, Codable, CaseIterable {
                case containedWithin = "contained_within"
                case country
                case countryCode = "country_code"
                case fullName = "full_name"
                case geo
                case id
                case name
                case placeType = "place_type"
            }

            public init(query: String, startTime: Date? = nil, endTime: Date? = nil, sinceID: String? = nil, untilID: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, paginationToken: String? = nil, sortOrder: SortOrder? = nil, tweetFields: [TweetFields]? = nil, expansions: [Expansions]? = nil, mediaFields: [MediaFields]? = nil, pollFields: [PollFields]? = nil, userFields: [UserFields]? = nil, placeFields: [PlaceFields]? = nil) {
                self.query = query
                self.startTime = startTime
                self.endTime = endTime
                self.sinceID = sinceID
                self.untilID = untilID
                self.maxResults = maxResults
                self.nextToken = nextToken
                self.paginationToken = paginationToken
                self.sortOrder = sortOrder
                self.tweetFields = tweetFields
                self.expansions = expansions
                self.mediaFields = mediaFields
                self.pollFields = pollFields
                self.userFields = userFields
                self.placeFields = placeFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(query, forKey: "query")
                encoder.encode(startTime, forKey: "start_time")
                encoder.encode(endTime, forKey: "end_time")
                encoder.encode(sinceID, forKey: "since_id")
                encoder.encode(untilID, forKey: "until_id")
                encoder.encode(maxResults, forKey: "max_results")
                encoder.encode(nextToken, forKey: "next_token")
                encoder.encode(paginationToken, forKey: "pagination_token")
                encoder.encode(sortOrder, forKey: "sort_order")
                encoder.encode(tweetFields, forKey: "tweet.fields", explode: false)
                encoder.encode(expansions, forKey: "expansions", explode: false)
                encoder.encode(mediaFields, forKey: "media.fields", explode: false)
                encoder.encode(pollFields, forKey: "poll.fields", explode: false)
                encoder.encode(userFields, forKey: "user.fields", explode: false)
                encoder.encode(placeFields, forKey: "place.fields", explode: false)
                return encoder.items
            }
        }
    }
}

extension Paths.Tweets.Search {
    public var recent: Recent {
        Recent(path: path + "/recent")
    }

    public struct Recent {
        /// Path: `/2/tweets/search/recent`
        public let path: String

        /// Recent search
        ///
        /// Returns Tweets from the last 7 days that match a search query.
        public func get(parameters: GetParameters) -> Request<TwitterAPI.Get2TweetsSearchRecentResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            /// Example: "(from:TwitterDev OR from:TwitterAPI) has:media -is:retweet"
            public var query: String
            public var startTime: Date?
            public var endTime: Date?
            /// Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
            ///
            /// Example: "1346889436626259968"
            public var sinceID: String?
            /// Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
            ///
            /// Example: "1346889436626259968"
            public var untilID: String?
            public var maxResults: Int?
            /// A base36 pagination token.
            public var nextToken: String?
            /// A base36 pagination token.
            public var paginationToken: String?
            public var sortOrder: SortOrder?
            /// The fields available for a Tweet object.
            ///
            /// Example: ["attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"]
            public var tweetFields: [TweetFields]?
            /// The list of fields you can expand for a [Tweet](#Tweet) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["attachments.media_keys", "attachments.poll_ids", "author_id", "entities.mentions.username", "geo.place_id", "in_reply_to_user_id", "referenced_tweets.id", "referenced_tweets.id.author_id"]
            public var expansions: [Expansions]?
            /// The fields available for a Media object.
            ///
            /// Example: ["alt_text", "duration_ms", "height", "media_key", "non_public_metrics", "organic_metrics", "preview_image_url", "promoted_metrics", "public_metrics", "type", "url", "variants", "width"]
            public var mediaFields: [MediaFields]?
            /// The fields available for a Poll object.
            ///
            /// Example: ["duration_minutes", "end_datetime", "id", "options", "voting_status"]
            public var pollFields: [PollFields]?
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?
            /// The fields available for a Place object.
            ///
            /// Example: ["contained_within", "country", "country_code", "full_name", "geo", "id", "name", "place_type"]
            public var placeFields: [PlaceFields]?

            public enum SortOrder: String, Codable, CaseIterable {
                case recency
                case relevancy
            }

            public enum TweetFields: String, Codable, CaseIterable {
                case attachments
                case authorID = "author_id"
                case contextAnnotations = "context_annotations"
                case conversationID = "conversation_id"
                case createdAt = "created_at"
                case entities
                case geo
                case id
                case inReplyToUserID = "in_reply_to_user_id"
                case lang
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case possiblySensitive = "possibly_sensitive"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case referencedTweets = "referenced_tweets"
                case replySettings = "reply_settings"
                case source
                case text
                case withheld
            }

            public enum Expansions: String, Codable, CaseIterable {
                case attachmentsMediaKeys = "attachments.media_keys"
                case attachmentsPollIDs = "attachments.poll_ids"
                case authorID = "author_id"
                case entitiesMentionsUsername = "entities.mentions.username"
                case geoPlaceID = "geo.place_id"
                case inReplyToUserID = "in_reply_to_user_id"
                case referencedTweetsID = "referenced_tweets.id"
                case referencedTweetsIDAuthorId = "referenced_tweets.id.author_id"
            }

            public enum MediaFields: String, Codable, CaseIterable {
                case altText = "alt_text"
                case durationMs = "duration_ms"
                case height
                case mediaKey = "media_key"
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case previewImageURL = "preview_image_url"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case type
                case url
                case variants
                case width
            }

            public enum PollFields: String, Codable, CaseIterable {
                case durationMinutes = "duration_minutes"
                case endDatetime = "end_datetime"
                case id
                case options
                case votingStatus = "voting_status"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public enum PlaceFields: String, Codable, CaseIterable {
                case containedWithin = "contained_within"
                case country
                case countryCode = "country_code"
                case fullName = "full_name"
                case geo
                case id
                case name
                case placeType = "place_type"
            }

            public init(query: String, startTime: Date? = nil, endTime: Date? = nil, sinceID: String? = nil, untilID: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, paginationToken: String? = nil, sortOrder: SortOrder? = nil, tweetFields: [TweetFields]? = nil, expansions: [Expansions]? = nil, mediaFields: [MediaFields]? = nil, pollFields: [PollFields]? = nil, userFields: [UserFields]? = nil, placeFields: [PlaceFields]? = nil) {
                self.query = query
                self.startTime = startTime
                self.endTime = endTime
                self.sinceID = sinceID
                self.untilID = untilID
                self.maxResults = maxResults
                self.nextToken = nextToken
                self.paginationToken = paginationToken
                self.sortOrder = sortOrder
                self.tweetFields = tweetFields
                self.expansions = expansions
                self.mediaFields = mediaFields
                self.pollFields = pollFields
                self.userFields = userFields
                self.placeFields = placeFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(query, forKey: "query")
                encoder.encode(startTime, forKey: "start_time")
                encoder.encode(endTime, forKey: "end_time")
                encoder.encode(sinceID, forKey: "since_id")
                encoder.encode(untilID, forKey: "until_id")
                encoder.encode(maxResults, forKey: "max_results")
                encoder.encode(nextToken, forKey: "next_token")
                encoder.encode(paginationToken, forKey: "pagination_token")
                encoder.encode(sortOrder, forKey: "sort_order")
                encoder.encode(tweetFields, forKey: "tweet.fields", explode: false)
                encoder.encode(expansions, forKey: "expansions", explode: false)
                encoder.encode(mediaFields, forKey: "media.fields", explode: false)
                encoder.encode(pollFields, forKey: "poll.fields", explode: false)
                encoder.encode(userFields, forKey: "user.fields", explode: false)
                encoder.encode(placeFields, forKey: "place.fields", explode: false)
                return encoder.items
            }
        }
    }
}

extension Paths.Tweets.Search {
    public var stream: Stream {
        Stream(path: path + "/stream")
    }

    public struct Stream {
        /// Path: `/2/tweets/search/stream`
        public let path: String

        /// Filtered stream
        ///
        /// Streams Tweets matching the stream's active rule set.
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.FilteredStreamingTweetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var backfillMinutes: Int?
            public var startTime: Date?
            public var endTime: Date?
            /// The fields available for a Tweet object.
            ///
            /// Example: ["attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"]
            public var tweetFields: [TweetFields]?
            /// The list of fields you can expand for a [Tweet](#Tweet) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["attachments.media_keys", "attachments.poll_ids", "author_id", "entities.mentions.username", "geo.place_id", "in_reply_to_user_id", "referenced_tweets.id", "referenced_tweets.id.author_id"]
            public var expansions: [Expansions]?
            /// The fields available for a Media object.
            ///
            /// Example: ["alt_text", "duration_ms", "height", "media_key", "non_public_metrics", "organic_metrics", "preview_image_url", "promoted_metrics", "public_metrics", "type", "url", "variants", "width"]
            public var mediaFields: [MediaFields]?
            /// The fields available for a Poll object.
            ///
            /// Example: ["duration_minutes", "end_datetime", "id", "options", "voting_status"]
            public var pollFields: [PollFields]?
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?
            /// The fields available for a Place object.
            ///
            /// Example: ["contained_within", "country", "country_code", "full_name", "geo", "id", "name", "place_type"]
            public var placeFields: [PlaceFields]?

            public enum TweetFields: String, Codable, CaseIterable {
                case attachments
                case authorID = "author_id"
                case contextAnnotations = "context_annotations"
                case conversationID = "conversation_id"
                case createdAt = "created_at"
                case entities
                case geo
                case id
                case inReplyToUserID = "in_reply_to_user_id"
                case lang
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case possiblySensitive = "possibly_sensitive"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case referencedTweets = "referenced_tweets"
                case replySettings = "reply_settings"
                case source
                case text
                case withheld
            }

            public enum Expansions: String, Codable, CaseIterable {
                case attachmentsMediaKeys = "attachments.media_keys"
                case attachmentsPollIDs = "attachments.poll_ids"
                case authorID = "author_id"
                case entitiesMentionsUsername = "entities.mentions.username"
                case geoPlaceID = "geo.place_id"
                case inReplyToUserID = "in_reply_to_user_id"
                case referencedTweetsID = "referenced_tweets.id"
                case referencedTweetsIDAuthorId = "referenced_tweets.id.author_id"
            }

            public enum MediaFields: String, Codable, CaseIterable {
                case altText = "alt_text"
                case durationMs = "duration_ms"
                case height
                case mediaKey = "media_key"
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case previewImageURL = "preview_image_url"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case type
                case url
                case variants
                case width
            }

            public enum PollFields: String, Codable, CaseIterable {
                case durationMinutes = "duration_minutes"
                case endDatetime = "end_datetime"
                case id
                case options
                case votingStatus = "voting_status"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public enum PlaceFields: String, Codable, CaseIterable {
                case containedWithin = "contained_within"
                case country
                case countryCode = "country_code"
                case fullName = "full_name"
                case geo
                case id
                case name
                case placeType = "place_type"
            }

            public init(backfillMinutes: Int? = nil, startTime: Date? = nil, endTime: Date? = nil, tweetFields: [TweetFields]? = nil, expansions: [Expansions]? = nil, mediaFields: [MediaFields]? = nil, pollFields: [PollFields]? = nil, userFields: [UserFields]? = nil, placeFields: [PlaceFields]? = nil) {
                self.backfillMinutes = backfillMinutes
                self.startTime = startTime
                self.endTime = endTime
                self.tweetFields = tweetFields
                self.expansions = expansions
                self.mediaFields = mediaFields
                self.pollFields = pollFields
                self.userFields = userFields
                self.placeFields = placeFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(backfillMinutes, forKey: "backfill_minutes")
                encoder.encode(startTime, forKey: "start_time")
                encoder.encode(endTime, forKey: "end_time")
                encoder.encode(tweetFields, forKey: "tweet.fields")
                encoder.encode(expansions, forKey: "expansions")
                encoder.encode(mediaFields, forKey: "media.fields")
                encoder.encode(pollFields, forKey: "poll.fields")
                encoder.encode(userFields, forKey: "user.fields")
                encoder.encode(placeFields, forKey: "place.fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Tweets.Search.Stream {
    public var rules: Rules {
        Rules(path: path + "/rules")
    }

    public struct Rules {
        /// Path: `/2/tweets/search/stream/rules`
        public let path: String

        /// Rules lookup
        ///
        /// Returns rules from a User's active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids.
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.RulesLookupResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var ids: [String]?
            public var maxResults: Int?
            public var paginationToken: String?

            public init(ids: [String]? = nil, maxResults: Int? = nil, paginationToken: String? = nil) {
                self.ids = ids
                self.maxResults = maxResults
                self.paginationToken = paginationToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(ids, forKey: "ids")
                encoder.encode(maxResults, forKey: "max_results")
                encoder.encode(paginationToken, forKey: "pagination_token")
                return encoder.items
            }
        }

        /// Add/Delete rules
        ///
        /// Add or delete rules from a User's active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values.
        public func post(isDryRun: Bool? = nil, _ body: TwitterAPI.AddOrDeleteRulesRequest) -> Request<TwitterAPI.AddOrDeleteRulesResponse> {
            .post(path, query: makePostQuery(isDryRun), body: body)
        }

        private func makePostQuery(_ isDryRun: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isDryRun, forKey: "dry_run")
            return encoder.items
        }
    }
}

extension Paths.Tweets {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/2/tweets/{id}`
        public let path: String

        /// Tweet lookup by Tweet ID
        ///
        /// Returns a variety of information about the Tweet specified by the requested ID.
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.Get2TweetsIDResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// The fields available for a Tweet object.
            ///
            /// Example: ["attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"]
            public var tweetFields: [TweetFields]?
            /// The list of fields you can expand for a [Tweet](#Tweet) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["attachments.media_keys", "attachments.poll_ids", "author_id", "entities.mentions.username", "geo.place_id", "in_reply_to_user_id", "referenced_tweets.id", "referenced_tweets.id.author_id"]
            public var expansions: [Expansions]?
            /// The fields available for a Media object.
            ///
            /// Example: ["alt_text", "duration_ms", "height", "media_key", "non_public_metrics", "organic_metrics", "preview_image_url", "promoted_metrics", "public_metrics", "type", "url", "variants", "width"]
            public var mediaFields: [MediaFields]?
            /// The fields available for a Poll object.
            ///
            /// Example: ["duration_minutes", "end_datetime", "id", "options", "voting_status"]
            public var pollFields: [PollFields]?
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?
            /// The fields available for a Place object.
            ///
            /// Example: ["contained_within", "country", "country_code", "full_name", "geo", "id", "name", "place_type"]
            public var placeFields: [PlaceFields]?

            public enum TweetFields: String, Codable, CaseIterable {
                case attachments
                case authorID = "author_id"
                case contextAnnotations = "context_annotations"
                case conversationID = "conversation_id"
                case createdAt = "created_at"
                case entities
                case geo
                case id
                case inReplyToUserID = "in_reply_to_user_id"
                case lang
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case possiblySensitive = "possibly_sensitive"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case referencedTweets = "referenced_tweets"
                case replySettings = "reply_settings"
                case source
                case text
                case withheld
            }

            public enum Expansions: String, Codable, CaseIterable {
                case attachmentsMediaKeys = "attachments.media_keys"
                case attachmentsPollIDs = "attachments.poll_ids"
                case authorID = "author_id"
                case entitiesMentionsUsername = "entities.mentions.username"
                case geoPlaceID = "geo.place_id"
                case inReplyToUserID = "in_reply_to_user_id"
                case referencedTweetsID = "referenced_tweets.id"
                case referencedTweetsIDAuthorId = "referenced_tweets.id.author_id"
            }

            public enum MediaFields: String, Codable, CaseIterable {
                case altText = "alt_text"
                case durationMs = "duration_ms"
                case height
                case mediaKey = "media_key"
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case previewImageURL = "preview_image_url"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case type
                case url
                case variants
                case width
            }

            public enum PollFields: String, Codable, CaseIterable {
                case durationMinutes = "duration_minutes"
                case endDatetime = "end_datetime"
                case id
                case options
                case votingStatus = "voting_status"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public enum PlaceFields: String, Codable, CaseIterable {
                case containedWithin = "contained_within"
                case country
                case countryCode = "country_code"
                case fullName = "full_name"
                case geo
                case id
                case name
                case placeType = "place_type"
            }

            public init(tweetFields: [TweetFields]? = nil, expansions: [Expansions]? = nil, mediaFields: [MediaFields]? = nil, pollFields: [PollFields]? = nil, userFields: [UserFields]? = nil, placeFields: [PlaceFields]? = nil) {
                self.tweetFields = tweetFields
                self.expansions = expansions
                self.mediaFields = mediaFields
                self.pollFields = pollFields
                self.userFields = userFields
                self.placeFields = placeFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(tweetFields, forKey: "tweet.fields")
                encoder.encode(expansions, forKey: "expansions")
                encoder.encode(mediaFields, forKey: "media.fields")
                encoder.encode(pollFields, forKey: "poll.fields")
                encoder.encode(userFields, forKey: "user.fields")
                encoder.encode(placeFields, forKey: "place.fields")
                return encoder.items
            }
        }

        /// Tweet delete by Tweet ID
        ///
        /// Delete specified Tweet (in the path) by ID.
        public var delete: Request<TwitterAPI.TweetDeleteResponse> {
            .delete(path)
        }
    }
}

extension Paths.Tweets.WithID {
    public var likingUsers: LikingUsers {
        LikingUsers(path: path + "/liking_users")
    }

    public struct LikingUsers {
        /// Path: `/2/tweets/{id}/liking_users`
        public let path: String

        /// Returns User objects that have liked the provided Tweet ID
        ///
        /// Returns a list of Users that have liked the provided Tweet ID
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.Get2TweetsIDLikingUsersResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var maxResults: Int?
            /// A base36 pagination token.
            public var paginationToken: String?
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?
            /// The list of fields you can expand for a [User](#User) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["pinned_tweet_id"]
            public var expansions: [Expansions]?
            /// The fields available for a Tweet object.
            ///
            /// Example: ["attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"]
            public var tweetFields: [TweetFields]?

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public enum Expansions: String, Codable, CaseIterable {
                case pinnedTweetID = "pinned_tweet_id"
            }

            public enum TweetFields: String, Codable, CaseIterable {
                case attachments
                case authorID = "author_id"
                case contextAnnotations = "context_annotations"
                case conversationID = "conversation_id"
                case createdAt = "created_at"
                case entities
                case geo
                case id
                case inReplyToUserID = "in_reply_to_user_id"
                case lang
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case possiblySensitive = "possibly_sensitive"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case referencedTweets = "referenced_tweets"
                case replySettings = "reply_settings"
                case source
                case text
                case withheld
            }

            public init(maxResults: Int? = nil, paginationToken: String? = nil, userFields: [UserFields]? = nil, expansions: [Expansions]? = nil, tweetFields: [TweetFields]? = nil) {
                self.maxResults = maxResults
                self.paginationToken = paginationToken
                self.userFields = userFields
                self.expansions = expansions
                self.tweetFields = tweetFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(maxResults, forKey: "max_results")
                encoder.encode(paginationToken, forKey: "pagination_token")
                encoder.encode(userFields, forKey: "user.fields")
                encoder.encode(expansions, forKey: "expansions")
                encoder.encode(tweetFields, forKey: "tweet.fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Tweets.WithID {
    public var quoteTweets: QuoteTweets {
        QuoteTweets(path: path + "/quote_tweets")
    }

    public struct QuoteTweets {
        /// Path: `/2/tweets/{id}/quote_tweets`
        public let path: String

        /// Retrieve Tweets that quote a Tweet.
        ///
        /// Returns a variety of information about each Tweet that quotes the Tweet specified by the requested ID.
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.Get2TweetsIDQuoteTweetsResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var maxResults: Int?
            /// A base36 pagination token.
            public var paginationToken: String?
            /// Example: ["replies", "retweets"]
            public var exclude: [Exclude]?
            /// The fields available for a Tweet object.
            ///
            /// Example: ["attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"]
            public var tweetFields: [TweetFields]?
            /// The list of fields you can expand for a [Tweet](#Tweet) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["attachments.media_keys", "attachments.poll_ids", "author_id", "entities.mentions.username", "geo.place_id", "in_reply_to_user_id", "referenced_tweets.id", "referenced_tweets.id.author_id"]
            public var expansions: [Expansions]?
            /// The fields available for a Media object.
            ///
            /// Example: ["alt_text", "duration_ms", "height", "media_key", "non_public_metrics", "organic_metrics", "preview_image_url", "promoted_metrics", "public_metrics", "type", "url", "variants", "width"]
            public var mediaFields: [MediaFields]?
            /// The fields available for a Poll object.
            ///
            /// Example: ["duration_minutes", "end_datetime", "id", "options", "voting_status"]
            public var pollFields: [PollFields]?
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?
            /// The fields available for a Place object.
            ///
            /// Example: ["contained_within", "country", "country_code", "full_name", "geo", "id", "name", "place_type"]
            public var placeFields: [PlaceFields]?

            public enum Exclude: String, Codable, CaseIterable {
                case replies
                case retweets
            }

            public enum TweetFields: String, Codable, CaseIterable {
                case attachments
                case authorID = "author_id"
                case contextAnnotations = "context_annotations"
                case conversationID = "conversation_id"
                case createdAt = "created_at"
                case entities
                case geo
                case id
                case inReplyToUserID = "in_reply_to_user_id"
                case lang
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case possiblySensitive = "possibly_sensitive"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case referencedTweets = "referenced_tweets"
                case replySettings = "reply_settings"
                case source
                case text
                case withheld
            }

            public enum Expansions: String, Codable, CaseIterable {
                case attachmentsMediaKeys = "attachments.media_keys"
                case attachmentsPollIDs = "attachments.poll_ids"
                case authorID = "author_id"
                case entitiesMentionsUsername = "entities.mentions.username"
                case geoPlaceID = "geo.place_id"
                case inReplyToUserID = "in_reply_to_user_id"
                case referencedTweetsID = "referenced_tweets.id"
                case referencedTweetsIDAuthorId = "referenced_tweets.id.author_id"
            }

            public enum MediaFields: String, Codable, CaseIterable {
                case altText = "alt_text"
                case durationMs = "duration_ms"
                case height
                case mediaKey = "media_key"
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case previewImageURL = "preview_image_url"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case type
                case url
                case variants
                case width
            }

            public enum PollFields: String, Codable, CaseIterable {
                case durationMinutes = "duration_minutes"
                case endDatetime = "end_datetime"
                case id
                case options
                case votingStatus = "voting_status"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public enum PlaceFields: String, Codable, CaseIterable {
                case containedWithin = "contained_within"
                case country
                case countryCode = "country_code"
                case fullName = "full_name"
                case geo
                case id
                case name
                case placeType = "place_type"
            }

            public init(maxResults: Int? = nil, paginationToken: String? = nil, exclude: [Exclude]? = nil, tweetFields: [TweetFields]? = nil, expansions: [Expansions]? = nil, mediaFields: [MediaFields]? = nil, pollFields: [PollFields]? = nil, userFields: [UserFields]? = nil, placeFields: [PlaceFields]? = nil) {
                self.maxResults = maxResults
                self.paginationToken = paginationToken
                self.exclude = exclude
                self.tweetFields = tweetFields
                self.expansions = expansions
                self.mediaFields = mediaFields
                self.pollFields = pollFields
                self.userFields = userFields
                self.placeFields = placeFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(maxResults, forKey: "max_results")
                encoder.encode(paginationToken, forKey: "pagination_token")
                encoder.encode(exclude, forKey: "exclude")
                encoder.encode(tweetFields, forKey: "tweet.fields")
                encoder.encode(expansions, forKey: "expansions")
                encoder.encode(mediaFields, forKey: "media.fields")
                encoder.encode(pollFields, forKey: "poll.fields")
                encoder.encode(userFields, forKey: "user.fields")
                encoder.encode(placeFields, forKey: "place.fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Tweets.WithID {
    public var retweetedBy: RetweetedBy {
        RetweetedBy(path: path + "/retweeted_by")
    }

    public struct RetweetedBy {
        /// Path: `/2/tweets/{id}/retweeted_by`
        public let path: String

        /// Returns User objects that have retweeted the provided Tweet ID
        ///
        /// Returns a list of Users that have retweeted the provided Tweet ID
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.Get2TweetsIDRetweetedByResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var maxResults: Int?
            /// A base36 pagination token.
            public var paginationToken: String?
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?
            /// The list of fields you can expand for a [User](#User) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["pinned_tweet_id"]
            public var expansions: [Expansions]?
            /// The fields available for a Tweet object.
            ///
            /// Example: ["attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"]
            public var tweetFields: [TweetFields]?

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public enum Expansions: String, Codable, CaseIterable {
                case pinnedTweetID = "pinned_tweet_id"
            }

            public enum TweetFields: String, Codable, CaseIterable {
                case attachments
                case authorID = "author_id"
                case contextAnnotations = "context_annotations"
                case conversationID = "conversation_id"
                case createdAt = "created_at"
                case entities
                case geo
                case id
                case inReplyToUserID = "in_reply_to_user_id"
                case lang
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case possiblySensitive = "possibly_sensitive"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case referencedTweets = "referenced_tweets"
                case replySettings = "reply_settings"
                case source
                case text
                case withheld
            }

            public init(maxResults: Int? = nil, paginationToken: String? = nil, userFields: [UserFields]? = nil, expansions: [Expansions]? = nil, tweetFields: [TweetFields]? = nil) {
                self.maxResults = maxResults
                self.paginationToken = paginationToken
                self.userFields = userFields
                self.expansions = expansions
                self.tweetFields = tweetFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(maxResults, forKey: "max_results")
                encoder.encode(paginationToken, forKey: "pagination_token")
                encoder.encode(userFields, forKey: "user.fields")
                encoder.encode(expansions, forKey: "expansions")
                encoder.encode(tweetFields, forKey: "tweet.fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Tweets {
    public func tweetID(_ tweetID: String) -> WithTweetID {
        WithTweetID(path: "\(path)/\(tweetID)")
    }

    public struct WithTweetID {
        /// Path: `/2/tweets/{tweet_id}`
        public let path: String
    }
}

extension Paths.Tweets.WithTweetID {
    public var hidden: Hidden {
        Hidden(path: path + "/hidden")
    }

    public struct Hidden {
        /// Path: `/2/tweets/{tweet_id}/hidden`
        public let path: String

        /// Hide replies
        ///
        /// Hides or unhides a reply to an owned conversation.
        public func put(_ body: TwitterAPI.TweetHideRequest? = nil) -> Request<TwitterAPI.TweetHideResponse> {
            .put(path, body: body)
        }
    }
}

extension Paths {
    public static var users: Users {
        Users(path: "/2/users")
    }

    public struct Users {
        /// Path: `/2/users`
        public let path: String

        /// User lookup by IDs
        ///
        /// This endpoint returns information about Users. Specify Users by their ID.
        public func get(parameters: GetParameters) -> Request<TwitterAPI.Get2UsersResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var ids: [String]
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?
            /// The list of fields you can expand for a [User](#User) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["pinned_tweet_id"]
            public var expansions: [Expansions]?
            /// The fields available for a Tweet object.
            ///
            /// Example: ["attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"]
            public var tweetFields: [TweetFields]?

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public enum Expansions: String, Codable, CaseIterable {
                case pinnedTweetID = "pinned_tweet_id"
            }

            public enum TweetFields: String, Codable, CaseIterable {
                case attachments
                case authorID = "author_id"
                case contextAnnotations = "context_annotations"
                case conversationID = "conversation_id"
                case createdAt = "created_at"
                case entities
                case geo
                case id
                case inReplyToUserID = "in_reply_to_user_id"
                case lang
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case possiblySensitive = "possibly_sensitive"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case referencedTweets = "referenced_tweets"
                case replySettings = "reply_settings"
                case source
                case text
                case withheld
            }

            public init(ids: [String], userFields: [UserFields]? = nil, expansions: [Expansions]? = nil, tweetFields: [TweetFields]? = nil) {
                self.ids = ids
                self.userFields = userFields
                self.expansions = expansions
                self.tweetFields = tweetFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(ids, forKey: "ids")
                encoder.encode(userFields, forKey: "user.fields")
                encoder.encode(expansions, forKey: "expansions")
                encoder.encode(tweetFields, forKey: "tweet.fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Users {
    public var by: By {
        By(path: path + "/by")
    }

    public struct By {
        /// Path: `/2/users/by`
        public let path: String

        /// User lookup by usernames
        ///
        /// This endpoint returns information about Users. Specify Users by their username.
        public func get(parameters: GetParameters) -> Request<TwitterAPI.Get2UsersByResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            /// Example: "TwitterDev,TwitterAPI"
            public var usernames: [String]
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?
            /// The list of fields you can expand for a [User](#User) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["pinned_tweet_id"]
            public var expansions: [Expansions]?
            /// The fields available for a Tweet object.
            ///
            /// Example: ["attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"]
            public var tweetFields: [TweetFields]?

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public enum Expansions: String, Codable, CaseIterable {
                case pinnedTweetID = "pinned_tweet_id"
            }

            public enum TweetFields: String, Codable, CaseIterable {
                case attachments
                case authorID = "author_id"
                case contextAnnotations = "context_annotations"
                case conversationID = "conversation_id"
                case createdAt = "created_at"
                case entities
                case geo
                case id
                case inReplyToUserID = "in_reply_to_user_id"
                case lang
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case possiblySensitive = "possibly_sensitive"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case referencedTweets = "referenced_tweets"
                case replySettings = "reply_settings"
                case source
                case text
                case withheld
            }

            public init(usernames: [String], userFields: [UserFields]? = nil, expansions: [Expansions]? = nil, tweetFields: [TweetFields]? = nil) {
                self.usernames = usernames
                self.userFields = userFields
                self.expansions = expansions
                self.tweetFields = tweetFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(usernames, forKey: "usernames")
                encoder.encode(userFields, forKey: "user.fields")
                encoder.encode(expansions, forKey: "expansions")
                encoder.encode(tweetFields, forKey: "tweet.fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Users.By {
    public var username: Username {
        Username(path: path + "/username")
    }

    public struct Username {
        /// Path: `/2/users/by/username`
        public let path: String
    }
}

extension Paths.Users.By.Username {
    public func username(_ username: String) -> WithUsername {
        WithUsername(path: "\(path)/\(username)")
    }

    public struct WithUsername {
        /// Path: `/2/users/by/username/{username}`
        public let path: String

        /// User lookup by username
        ///
        /// This endpoint returns information about a User. Specify User by username.
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.Get2UsersByUsernameUsernameResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?
            /// The list of fields you can expand for a [User](#User) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["pinned_tweet_id"]
            public var expansions: [Expansions]?
            /// The fields available for a Tweet object.
            ///
            /// Example: ["attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"]
            public var tweetFields: [TweetFields]?

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public enum Expansions: String, Codable, CaseIterable {
                case pinnedTweetID = "pinned_tweet_id"
            }

            public enum TweetFields: String, Codable, CaseIterable {
                case attachments
                case authorID = "author_id"
                case contextAnnotations = "context_annotations"
                case conversationID = "conversation_id"
                case createdAt = "created_at"
                case entities
                case geo
                case id
                case inReplyToUserID = "in_reply_to_user_id"
                case lang
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case possiblySensitive = "possibly_sensitive"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case referencedTweets = "referenced_tweets"
                case replySettings = "reply_settings"
                case source
                case text
                case withheld
            }

            public init(userFields: [UserFields]? = nil, expansions: [Expansions]? = nil, tweetFields: [TweetFields]? = nil) {
                self.userFields = userFields
                self.expansions = expansions
                self.tweetFields = tweetFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(userFields, forKey: "user.fields")
                encoder.encode(expansions, forKey: "expansions")
                encoder.encode(tweetFields, forKey: "tweet.fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Users {
    public var compliance: Compliance {
        Compliance(path: path + "/compliance")
    }

    public struct Compliance {
        /// Path: `/2/users/compliance`
        public let path: String
    }
}

extension Paths.Users.Compliance {
    public var stream: Stream {
        Stream(path: path + "/stream")
    }

    public struct Stream {
        /// Path: `/2/users/compliance/stream`
        public let path: String

        /// Users Compliance stream
        ///
        /// Streams 100% of compliance data for Users
        public func get(parameters: GetParameters) -> Request<TwitterAPI.UserComplianceStreamResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var backfillMinutes: Int?
            public var partition: Int
            public var startTime: Date?
            public var endTime: Date?

            public init(backfillMinutes: Int? = nil, partition: Int, startTime: Date? = nil, endTime: Date? = nil) {
                self.backfillMinutes = backfillMinutes
                self.partition = partition
                self.startTime = startTime
                self.endTime = endTime
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(backfillMinutes, forKey: "backfill_minutes")
                encoder.encode(partition, forKey: "partition")
                encoder.encode(startTime, forKey: "start_time")
                encoder.encode(endTime, forKey: "end_time")
                return encoder.items
            }
        }
    }
}

extension Paths.Users {
    public var me: Me {
        Me(path: path + "/me")
    }

    public struct Me {
        /// Path: `/2/users/me`
        public let path: String

        /// User lookup me
        ///
        /// This endpoint returns information about the requesting User.
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.Get2UsersMeResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?
            /// The list of fields you can expand for a [User](#User) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["pinned_tweet_id"]
            public var expansions: [Expansions]?
            /// The fields available for a Tweet object.
            ///
            /// Example: ["attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"]
            public var tweetFields: [TweetFields]?

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public enum Expansions: String, Codable, CaseIterable {
                case pinnedTweetID = "pinned_tweet_id"
            }

            public enum TweetFields: String, Codable, CaseIterable {
                case attachments
                case authorID = "author_id"
                case contextAnnotations = "context_annotations"
                case conversationID = "conversation_id"
                case createdAt = "created_at"
                case entities
                case geo
                case id
                case inReplyToUserID = "in_reply_to_user_id"
                case lang
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case possiblySensitive = "possibly_sensitive"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case referencedTweets = "referenced_tweets"
                case replySettings = "reply_settings"
                case source
                case text
                case withheld
            }

            public init(userFields: [UserFields]? = nil, expansions: [Expansions]? = nil, tweetFields: [TweetFields]? = nil) {
                self.userFields = userFields
                self.expansions = expansions
                self.tweetFields = tweetFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(userFields, forKey: "user.fields")
                encoder.encode(expansions, forKey: "expansions")
                encoder.encode(tweetFields, forKey: "tweet.fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Users {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/2/users/{id}`
        public let path: String

        /// User lookup by ID
        ///
        /// This endpoint returns information about a User. Specify User by ID.
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.Get2UsersIDResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?
            /// The list of fields you can expand for a [User](#User) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["pinned_tweet_id"]
            public var expansions: [Expansions]?
            /// The fields available for a Tweet object.
            ///
            /// Example: ["attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"]
            public var tweetFields: [TweetFields]?

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public enum Expansions: String, Codable, CaseIterable {
                case pinnedTweetID = "pinned_tweet_id"
            }

            public enum TweetFields: String, Codable, CaseIterable {
                case attachments
                case authorID = "author_id"
                case contextAnnotations = "context_annotations"
                case conversationID = "conversation_id"
                case createdAt = "created_at"
                case entities
                case geo
                case id
                case inReplyToUserID = "in_reply_to_user_id"
                case lang
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case possiblySensitive = "possibly_sensitive"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case referencedTweets = "referenced_tweets"
                case replySettings = "reply_settings"
                case source
                case text
                case withheld
            }

            public init(userFields: [UserFields]? = nil, expansions: [Expansions]? = nil, tweetFields: [TweetFields]? = nil) {
                self.userFields = userFields
                self.expansions = expansions
                self.tweetFields = tweetFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(userFields, forKey: "user.fields")
                encoder.encode(expansions, forKey: "expansions")
                encoder.encode(tweetFields, forKey: "tweet.fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Users.WithID {
    public var blocking: Blocking {
        Blocking(path: path + "/blocking")
    }

    public struct Blocking {
        /// Path: `/2/users/{id}/blocking`
        public let path: String

        /// Returns User objects that are blocked by provided User ID
        ///
        /// Returns a list of Users that are blocked by the provided User ID
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.Get2UsersIDBlockingResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var maxResults: Int?
            /// A base32 pagination token.
            public var paginationToken: String?
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?
            /// The list of fields you can expand for a [User](#User) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["pinned_tweet_id"]
            public var expansions: [Expansions]?
            /// The fields available for a Tweet object.
            ///
            /// Example: ["attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"]
            public var tweetFields: [TweetFields]?

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public enum Expansions: String, Codable, CaseIterable {
                case pinnedTweetID = "pinned_tweet_id"
            }

            public enum TweetFields: String, Codable, CaseIterable {
                case attachments
                case authorID = "author_id"
                case contextAnnotations = "context_annotations"
                case conversationID = "conversation_id"
                case createdAt = "created_at"
                case entities
                case geo
                case id
                case inReplyToUserID = "in_reply_to_user_id"
                case lang
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case possiblySensitive = "possibly_sensitive"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case referencedTweets = "referenced_tweets"
                case replySettings = "reply_settings"
                case source
                case text
                case withheld
            }

            public init(maxResults: Int? = nil, paginationToken: String? = nil, userFields: [UserFields]? = nil, expansions: [Expansions]? = nil, tweetFields: [TweetFields]? = nil) {
                self.maxResults = maxResults
                self.paginationToken = paginationToken
                self.userFields = userFields
                self.expansions = expansions
                self.tweetFields = tweetFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(maxResults, forKey: "max_results")
                encoder.encode(paginationToken, forKey: "pagination_token")
                encoder.encode(userFields, forKey: "user.fields")
                encoder.encode(expansions, forKey: "expansions")
                encoder.encode(tweetFields, forKey: "tweet.fields")
                return encoder.items
            }
        }

        /// Block User by User ID
        ///
        /// Causes the User (in the path) to block the target User. The User (in the path) must match the User context authorizing the request
        public func post(_ body: TwitterAPI.BlockUserRequest) -> Request<TwitterAPI.BlockUserMutationResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.Users.WithID {
    public var bookmarks: Bookmarks {
        Bookmarks(path: path + "/bookmarks")
    }

    public struct Bookmarks {
        /// Path: `/2/users/{id}/bookmarks`
        public let path: String

        /// Bookmarks by User
        ///
        /// Returns Tweet objects that have been bookmarked by the requesting User
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.Get2UsersIDBookmarksResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var maxResults: Int?
            /// A base36 pagination token.
            public var paginationToken: String?
            /// The fields available for a Tweet object.
            ///
            /// Example: ["attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"]
            public var tweetFields: [TweetFields]?
            /// The list of fields you can expand for a [Tweet](#Tweet) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["attachments.media_keys", "attachments.poll_ids", "author_id", "entities.mentions.username", "geo.place_id", "in_reply_to_user_id", "referenced_tweets.id", "referenced_tweets.id.author_id"]
            public var expansions: [Expansions]?
            /// The fields available for a Media object.
            ///
            /// Example: ["alt_text", "duration_ms", "height", "media_key", "non_public_metrics", "organic_metrics", "preview_image_url", "promoted_metrics", "public_metrics", "type", "url", "variants", "width"]
            public var mediaFields: [MediaFields]?
            /// The fields available for a Poll object.
            ///
            /// Example: ["duration_minutes", "end_datetime", "id", "options", "voting_status"]
            public var pollFields: [PollFields]?
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?
            /// The fields available for a Place object.
            ///
            /// Example: ["contained_within", "country", "country_code", "full_name", "geo", "id", "name", "place_type"]
            public var placeFields: [PlaceFields]?

            public enum TweetFields: String, Codable, CaseIterable {
                case attachments
                case authorID = "author_id"
                case contextAnnotations = "context_annotations"
                case conversationID = "conversation_id"
                case createdAt = "created_at"
                case entities
                case geo
                case id
                case inReplyToUserID = "in_reply_to_user_id"
                case lang
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case possiblySensitive = "possibly_sensitive"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case referencedTweets = "referenced_tweets"
                case replySettings = "reply_settings"
                case source
                case text
                case withheld
            }

            public enum Expansions: String, Codable, CaseIterable {
                case attachmentsMediaKeys = "attachments.media_keys"
                case attachmentsPollIDs = "attachments.poll_ids"
                case authorID = "author_id"
                case entitiesMentionsUsername = "entities.mentions.username"
                case geoPlaceID = "geo.place_id"
                case inReplyToUserID = "in_reply_to_user_id"
                case referencedTweetsID = "referenced_tweets.id"
                case referencedTweetsIDAuthorId = "referenced_tweets.id.author_id"
            }

            public enum MediaFields: String, Codable, CaseIterable {
                case altText = "alt_text"
                case durationMs = "duration_ms"
                case height
                case mediaKey = "media_key"
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case previewImageURL = "preview_image_url"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case type
                case url
                case variants
                case width
            }

            public enum PollFields: String, Codable, CaseIterable {
                case durationMinutes = "duration_minutes"
                case endDatetime = "end_datetime"
                case id
                case options
                case votingStatus = "voting_status"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public enum PlaceFields: String, Codable, CaseIterable {
                case containedWithin = "contained_within"
                case country
                case countryCode = "country_code"
                case fullName = "full_name"
                case geo
                case id
                case name
                case placeType = "place_type"
            }

            public init(maxResults: Int? = nil, paginationToken: String? = nil, tweetFields: [TweetFields]? = nil, expansions: [Expansions]? = nil, mediaFields: [MediaFields]? = nil, pollFields: [PollFields]? = nil, userFields: [UserFields]? = nil, placeFields: [PlaceFields]? = nil) {
                self.maxResults = maxResults
                self.paginationToken = paginationToken
                self.tweetFields = tweetFields
                self.expansions = expansions
                self.mediaFields = mediaFields
                self.pollFields = pollFields
                self.userFields = userFields
                self.placeFields = placeFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(maxResults, forKey: "max_results")
                encoder.encode(paginationToken, forKey: "pagination_token")
                encoder.encode(tweetFields, forKey: "tweet.fields")
                encoder.encode(expansions, forKey: "expansions")
                encoder.encode(mediaFields, forKey: "media.fields")
                encoder.encode(pollFields, forKey: "poll.fields")
                encoder.encode(userFields, forKey: "user.fields")
                encoder.encode(placeFields, forKey: "place.fields")
                return encoder.items
            }
        }

        /// Add Tweet to Bookmarks
        ///
        /// Adds a Tweet (ID in the body) to the requesting User's (in the path) bookmarks
        public func post(_ body: TwitterAPI.BookmarkAddRequest) -> Request<TwitterAPI.BookmarkMutationResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.Users.WithID.Bookmarks {
    public func tweetID(_ tweetID: String) -> WithTweetID {
        WithTweetID(path: "\(path)/\(tweetID)")
    }

    public struct WithTweetID {
        /// Path: `/2/users/{id}/bookmarks/{tweet_id}`
        public let path: String

        /// Remove a bookmarked Tweet
        ///
        /// Removes a Tweet from the requesting User's bookmarked Tweets.
        public var delete: Request<TwitterAPI.BookmarkMutationResponse> {
            .delete(path)
        }
    }
}

extension Paths.Users.WithID {
    public var followedLists: FollowedLists {
        FollowedLists(path: path + "/followed_lists")
    }

    public struct FollowedLists {
        /// Path: `/2/users/{id}/followed_lists`
        public let path: String

        /// Get User's Followed Lists
        ///
        /// Returns a User's followed Lists.
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.Get2UsersIDFollowedListsResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var maxResults: Int?
            /// A 'long' pagination token.
            public var paginationToken: String?
            /// The fields available for a List object.
            ///
            /// Example: ["created_at", "description", "follower_count", "id", "member_count", "name", "owner_id", "private"]
            public var listFields: [ListFields]?
            /// The list of fields you can expand for a [List](#List) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["owner_id"]
            public var expansions: [Expansions]?
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?

            public enum ListFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case followerCount = "follower_count"
                case id
                case memberCount = "member_count"
                case name
                case ownerID = "owner_id"
                case `private`
            }

            public enum Expansions: String, Codable, CaseIterable {
                case ownerID = "owner_id"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public init(maxResults: Int? = nil, paginationToken: String? = nil, listFields: [ListFields]? = nil, expansions: [Expansions]? = nil, userFields: [UserFields]? = nil) {
                self.maxResults = maxResults
                self.paginationToken = paginationToken
                self.listFields = listFields
                self.expansions = expansions
                self.userFields = userFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(maxResults, forKey: "max_results")
                encoder.encode(paginationToken, forKey: "pagination_token")
                encoder.encode(listFields, forKey: "list.fields")
                encoder.encode(expansions, forKey: "expansions")
                encoder.encode(userFields, forKey: "user.fields")
                return encoder.items
            }
        }

        /// Follow a List
        ///
        /// Causes a User to follow a List.
        public func post(_ body: TwitterAPI.ListFollowedRequest? = nil) -> Request<TwitterAPI.ListFollowedResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.Users.WithID.FollowedLists {
    public func listID(_ listID: String) -> WithListID {
        WithListID(path: "\(path)/\(listID)")
    }

    public struct WithListID {
        /// Path: `/2/users/{id}/followed_lists/{list_id}`
        public let path: String

        /// Unfollow a List
        ///
        /// Causes a User to unfollow a List.
        public var delete: Request<TwitterAPI.ListFollowedResponse> {
            .delete(path)
        }
    }
}

extension Paths.Users.WithID {
    public var followers: Followers {
        Followers(path: path + "/followers")
    }

    public struct Followers {
        /// Path: `/2/users/{id}/followers`
        public let path: String

        /// Returns User objects that follow a List by the provided User ID
        ///
        /// Returns a list of Users that follow the provided User ID
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.Get2UsersIDFollowersResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var maxResults: Int?
            /// A base32 pagination token.
            public var paginationToken: String?
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?
            /// The list of fields you can expand for a [User](#User) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["pinned_tweet_id"]
            public var expansions: [Expansions]?
            /// The fields available for a Tweet object.
            ///
            /// Example: ["attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"]
            public var tweetFields: [TweetFields]?

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public enum Expansions: String, Codable, CaseIterable {
                case pinnedTweetID = "pinned_tweet_id"
            }

            public enum TweetFields: String, Codable, CaseIterable {
                case attachments
                case authorID = "author_id"
                case contextAnnotations = "context_annotations"
                case conversationID = "conversation_id"
                case createdAt = "created_at"
                case entities
                case geo
                case id
                case inReplyToUserID = "in_reply_to_user_id"
                case lang
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case possiblySensitive = "possibly_sensitive"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case referencedTweets = "referenced_tweets"
                case replySettings = "reply_settings"
                case source
                case text
                case withheld
            }

            public init(maxResults: Int? = nil, paginationToken: String? = nil, userFields: [UserFields]? = nil, expansions: [Expansions]? = nil, tweetFields: [TweetFields]? = nil) {
                self.maxResults = maxResults
                self.paginationToken = paginationToken
                self.userFields = userFields
                self.expansions = expansions
                self.tweetFields = tweetFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(maxResults, forKey: "max_results")
                encoder.encode(paginationToken, forKey: "pagination_token")
                encoder.encode(userFields, forKey: "user.fields")
                encoder.encode(expansions, forKey: "expansions")
                encoder.encode(tweetFields, forKey: "tweet.fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Users.WithID {
    public var following: Following {
        Following(path: path + "/following")
    }

    public struct Following {
        /// Path: `/2/users/{id}/following`
        public let path: String

        /// Following by User ID
        ///
        /// Returns a list of Users that are being followed by the provided User ID
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.Get2UsersIDFollowingResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var maxResults: Int?
            /// A base32 pagination token.
            public var paginationToken: String?
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?
            /// The list of fields you can expand for a [User](#User) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["pinned_tweet_id"]
            public var expansions: [Expansions]?
            /// The fields available for a Tweet object.
            ///
            /// Example: ["attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"]
            public var tweetFields: [TweetFields]?

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public enum Expansions: String, Codable, CaseIterable {
                case pinnedTweetID = "pinned_tweet_id"
            }

            public enum TweetFields: String, Codable, CaseIterable {
                case attachments
                case authorID = "author_id"
                case contextAnnotations = "context_annotations"
                case conversationID = "conversation_id"
                case createdAt = "created_at"
                case entities
                case geo
                case id
                case inReplyToUserID = "in_reply_to_user_id"
                case lang
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case possiblySensitive = "possibly_sensitive"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case referencedTweets = "referenced_tweets"
                case replySettings = "reply_settings"
                case source
                case text
                case withheld
            }

            public init(maxResults: Int? = nil, paginationToken: String? = nil, userFields: [UserFields]? = nil, expansions: [Expansions]? = nil, tweetFields: [TweetFields]? = nil) {
                self.maxResults = maxResults
                self.paginationToken = paginationToken
                self.userFields = userFields
                self.expansions = expansions
                self.tweetFields = tweetFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(maxResults, forKey: "max_results")
                encoder.encode(paginationToken, forKey: "pagination_token")
                encoder.encode(userFields, forKey: "user.fields")
                encoder.encode(expansions, forKey: "expansions")
                encoder.encode(tweetFields, forKey: "tweet.fields")
                return encoder.items
            }
        }

        /// Follow User
        ///
        /// Causes the User(in the path) to follow, or request to follow for protected Users, the target User. The User(in the path) must match the User context authorizing the request
        public func post(_ body: TwitterAPI.UsersFollowingCreateRequest? = nil) -> Request<TwitterAPI.UsersFollowingCreateResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.Users.WithID {
    public var likedTweets: LikedTweets {
        LikedTweets(path: path + "/liked_tweets")
    }

    public struct LikedTweets {
        /// Path: `/2/users/{id}/liked_tweets`
        public let path: String

        /// Returns Tweet objects liked by the provided User ID
        ///
        /// Returns a list of Tweets liked by the provided User ID
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.Get2UsersIDLikedTweetsResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var maxResults: Int?
            /// A base36 pagination token.
            public var paginationToken: String?
            /// The fields available for a Tweet object.
            ///
            /// Example: ["attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"]
            public var tweetFields: [TweetFields]?
            /// The list of fields you can expand for a [Tweet](#Tweet) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["attachments.media_keys", "attachments.poll_ids", "author_id", "entities.mentions.username", "geo.place_id", "in_reply_to_user_id", "referenced_tweets.id", "referenced_tweets.id.author_id"]
            public var expansions: [Expansions]?
            /// The fields available for a Media object.
            ///
            /// Example: ["alt_text", "duration_ms", "height", "media_key", "non_public_metrics", "organic_metrics", "preview_image_url", "promoted_metrics", "public_metrics", "type", "url", "variants", "width"]
            public var mediaFields: [MediaFields]?
            /// The fields available for a Poll object.
            ///
            /// Example: ["duration_minutes", "end_datetime", "id", "options", "voting_status"]
            public var pollFields: [PollFields]?
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?
            /// The fields available for a Place object.
            ///
            /// Example: ["contained_within", "country", "country_code", "full_name", "geo", "id", "name", "place_type"]
            public var placeFields: [PlaceFields]?

            public enum TweetFields: String, Codable, CaseIterable {
                case attachments
                case authorID = "author_id"
                case contextAnnotations = "context_annotations"
                case conversationID = "conversation_id"
                case createdAt = "created_at"
                case entities
                case geo
                case id
                case inReplyToUserID = "in_reply_to_user_id"
                case lang
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case possiblySensitive = "possibly_sensitive"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case referencedTweets = "referenced_tweets"
                case replySettings = "reply_settings"
                case source
                case text
                case withheld
            }

            public enum Expansions: String, Codable, CaseIterable {
                case attachmentsMediaKeys = "attachments.media_keys"
                case attachmentsPollIDs = "attachments.poll_ids"
                case authorID = "author_id"
                case entitiesMentionsUsername = "entities.mentions.username"
                case geoPlaceID = "geo.place_id"
                case inReplyToUserID = "in_reply_to_user_id"
                case referencedTweetsID = "referenced_tweets.id"
                case referencedTweetsIDAuthorId = "referenced_tweets.id.author_id"
            }

            public enum MediaFields: String, Codable, CaseIterable {
                case altText = "alt_text"
                case durationMs = "duration_ms"
                case height
                case mediaKey = "media_key"
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case previewImageURL = "preview_image_url"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case type
                case url
                case variants
                case width
            }

            public enum PollFields: String, Codable, CaseIterable {
                case durationMinutes = "duration_minutes"
                case endDatetime = "end_datetime"
                case id
                case options
                case votingStatus = "voting_status"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public enum PlaceFields: String, Codable, CaseIterable {
                case containedWithin = "contained_within"
                case country
                case countryCode = "country_code"
                case fullName = "full_name"
                case geo
                case id
                case name
                case placeType = "place_type"
            }

            public init(maxResults: Int? = nil, paginationToken: String? = nil, tweetFields: [TweetFields]? = nil, expansions: [Expansions]? = nil, mediaFields: [MediaFields]? = nil, pollFields: [PollFields]? = nil, userFields: [UserFields]? = nil, placeFields: [PlaceFields]? = nil) {
                self.maxResults = maxResults
                self.paginationToken = paginationToken
                self.tweetFields = tweetFields
                self.expansions = expansions
                self.mediaFields = mediaFields
                self.pollFields = pollFields
                self.userFields = userFields
                self.placeFields = placeFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(maxResults, forKey: "max_results")
                encoder.encode(paginationToken, forKey: "pagination_token")
                encoder.encode(tweetFields, forKey: "tweet.fields")
                encoder.encode(expansions, forKey: "expansions")
                encoder.encode(mediaFields, forKey: "media.fields")
                encoder.encode(pollFields, forKey: "poll.fields")
                encoder.encode(userFields, forKey: "user.fields")
                encoder.encode(placeFields, forKey: "place.fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Users.WithID {
    public var likes: Likes {
        Likes(path: path + "/likes")
    }

    public struct Likes {
        /// Path: `/2/users/{id}/likes`
        public let path: String

        /// Causes the User (in the path) to like the specified Tweet
        ///
        /// Causes the User (in the path) to like the specified Tweet. The User in the path must match the User context authorizing the request.
        public func post(_ body: TwitterAPI.UsersLikesCreateRequest? = nil) -> Request<TwitterAPI.UsersLikesCreateResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.Users.WithID.Likes {
    public func tweetID(_ tweetID: String) -> WithTweetID {
        WithTweetID(path: "\(path)/\(tweetID)")
    }

    public struct WithTweetID {
        /// Path: `/2/users/{id}/likes/{tweet_id}`
        public let path: String

        /// Causes the User (in the path) to unlike the specified Tweet
        ///
        /// Causes the User (in the path) to unlike the specified Tweet. The User must match the User context authorizing the request
        public var delete: Request<TwitterAPI.UsersLikesDeleteResponse> {
            .delete(path)
        }
    }
}

extension Paths.Users.WithID {
    public var listMemberships: ListMemberships {
        ListMemberships(path: path + "/list_memberships")
    }

    public struct ListMemberships {
        /// Path: `/2/users/{id}/list_memberships`
        public let path: String

        /// Get a User's List Memberships
        ///
        /// Get a User's List Memberships.
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.Get2UsersIDListMembershipsResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var maxResults: Int?
            /// A 'long' pagination token.
            public var paginationToken: String?
            /// The fields available for a List object.
            ///
            /// Example: ["created_at", "description", "follower_count", "id", "member_count", "name", "owner_id", "private"]
            public var listFields: [ListFields]?
            /// The list of fields you can expand for a [List](#List) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["owner_id"]
            public var expansions: [Expansions]?
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?

            public enum ListFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case followerCount = "follower_count"
                case id
                case memberCount = "member_count"
                case name
                case ownerID = "owner_id"
                case `private`
            }

            public enum Expansions: String, Codable, CaseIterable {
                case ownerID = "owner_id"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public init(maxResults: Int? = nil, paginationToken: String? = nil, listFields: [ListFields]? = nil, expansions: [Expansions]? = nil, userFields: [UserFields]? = nil) {
                self.maxResults = maxResults
                self.paginationToken = paginationToken
                self.listFields = listFields
                self.expansions = expansions
                self.userFields = userFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(maxResults, forKey: "max_results")
                encoder.encode(paginationToken, forKey: "pagination_token")
                encoder.encode(listFields, forKey: "list.fields")
                encoder.encode(expansions, forKey: "expansions")
                encoder.encode(userFields, forKey: "user.fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Users.WithID {
    public var mentions: Mentions {
        Mentions(path: path + "/mentions")
    }

    public struct Mentions {
        /// Path: `/2/users/{id}/mentions`
        public let path: String

        /// User mention timeline by User ID
        ///
        /// Returns Tweet objects that mention username associated to the provided User ID
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.Get2UsersIDMentionsResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
            ///
            /// Example: "1346889436626259968"
            public var sinceID: String?
            /// Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
            ///
            /// Example: "1346889436626259968"
            public var untilID: String?
            public var maxResults: Int?
            /// A base36 pagination token.
            public var paginationToken: String?
            public var startTime: Date?
            public var endTime: Date?
            /// The fields available for a Tweet object.
            ///
            /// Example: ["attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"]
            public var tweetFields: [TweetFields]?
            /// The list of fields you can expand for a [Tweet](#Tweet) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["attachments.media_keys", "attachments.poll_ids", "author_id", "entities.mentions.username", "geo.place_id", "in_reply_to_user_id", "referenced_tweets.id", "referenced_tweets.id.author_id"]
            public var expansions: [Expansions]?
            /// The fields available for a Media object.
            ///
            /// Example: ["alt_text", "duration_ms", "height", "media_key", "non_public_metrics", "organic_metrics", "preview_image_url", "promoted_metrics", "public_metrics", "type", "url", "variants", "width"]
            public var mediaFields: [MediaFields]?
            /// The fields available for a Poll object.
            ///
            /// Example: ["duration_minutes", "end_datetime", "id", "options", "voting_status"]
            public var pollFields: [PollFields]?
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?
            /// The fields available for a Place object.
            ///
            /// Example: ["contained_within", "country", "country_code", "full_name", "geo", "id", "name", "place_type"]
            public var placeFields: [PlaceFields]?

            public enum TweetFields: String, Codable, CaseIterable {
                case attachments
                case authorID = "author_id"
                case contextAnnotations = "context_annotations"
                case conversationID = "conversation_id"
                case createdAt = "created_at"
                case entities
                case geo
                case id
                case inReplyToUserID = "in_reply_to_user_id"
                case lang
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case possiblySensitive = "possibly_sensitive"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case referencedTweets = "referenced_tweets"
                case replySettings = "reply_settings"
                case source
                case text
                case withheld
            }

            public enum Expansions: String, Codable, CaseIterable {
                case attachmentsMediaKeys = "attachments.media_keys"
                case attachmentsPollIDs = "attachments.poll_ids"
                case authorID = "author_id"
                case entitiesMentionsUsername = "entities.mentions.username"
                case geoPlaceID = "geo.place_id"
                case inReplyToUserID = "in_reply_to_user_id"
                case referencedTweetsID = "referenced_tweets.id"
                case referencedTweetsIDAuthorId = "referenced_tweets.id.author_id"
            }

            public enum MediaFields: String, Codable, CaseIterable {
                case altText = "alt_text"
                case durationMs = "duration_ms"
                case height
                case mediaKey = "media_key"
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case previewImageURL = "preview_image_url"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case type
                case url
                case variants
                case width
            }

            public enum PollFields: String, Codable, CaseIterable {
                case durationMinutes = "duration_minutes"
                case endDatetime = "end_datetime"
                case id
                case options
                case votingStatus = "voting_status"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public enum PlaceFields: String, Codable, CaseIterable {
                case containedWithin = "contained_within"
                case country
                case countryCode = "country_code"
                case fullName = "full_name"
                case geo
                case id
                case name
                case placeType = "place_type"
            }

            public init(sinceID: String? = nil, untilID: String? = nil, maxResults: Int? = nil, paginationToken: String? = nil, startTime: Date? = nil, endTime: Date? = nil, tweetFields: [TweetFields]? = nil, expansions: [Expansions]? = nil, mediaFields: [MediaFields]? = nil, pollFields: [PollFields]? = nil, userFields: [UserFields]? = nil, placeFields: [PlaceFields]? = nil) {
                self.sinceID = sinceID
                self.untilID = untilID
                self.maxResults = maxResults
                self.paginationToken = paginationToken
                self.startTime = startTime
                self.endTime = endTime
                self.tweetFields = tweetFields
                self.expansions = expansions
                self.mediaFields = mediaFields
                self.pollFields = pollFields
                self.userFields = userFields
                self.placeFields = placeFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(sinceID, forKey: "since_id")
                encoder.encode(untilID, forKey: "until_id")
                encoder.encode(maxResults, forKey: "max_results")
                encoder.encode(paginationToken, forKey: "pagination_token")
                encoder.encode(startTime, forKey: "start_time")
                encoder.encode(endTime, forKey: "end_time")
                encoder.encode(tweetFields, forKey: "tweet.fields")
                encoder.encode(expansions, forKey: "expansions")
                encoder.encode(mediaFields, forKey: "media.fields")
                encoder.encode(pollFields, forKey: "poll.fields")
                encoder.encode(userFields, forKey: "user.fields")
                encoder.encode(placeFields, forKey: "place.fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Users.WithID {
    public var muting: Muting {
        Muting(path: path + "/muting")
    }

    public struct Muting {
        /// Path: `/2/users/{id}/muting`
        public let path: String

        /// Returns User objects that are muted by the provided User ID
        ///
        /// Returns a list of Users that are muted by the provided User ID
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.Get2UsersIDMutingResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var maxResults: Int?
            /// A 'long' pagination token.
            public var paginationToken: String?
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?
            /// The list of fields you can expand for a [User](#User) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["pinned_tweet_id"]
            public var expansions: [Expansions]?
            /// The fields available for a Tweet object.
            ///
            /// Example: ["attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"]
            public var tweetFields: [TweetFields]?

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public enum Expansions: String, Codable, CaseIterable {
                case pinnedTweetID = "pinned_tweet_id"
            }

            public enum TweetFields: String, Codable, CaseIterable {
                case attachments
                case authorID = "author_id"
                case contextAnnotations = "context_annotations"
                case conversationID = "conversation_id"
                case createdAt = "created_at"
                case entities
                case geo
                case id
                case inReplyToUserID = "in_reply_to_user_id"
                case lang
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case possiblySensitive = "possibly_sensitive"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case referencedTweets = "referenced_tweets"
                case replySettings = "reply_settings"
                case source
                case text
                case withheld
            }

            public init(maxResults: Int? = nil, paginationToken: String? = nil, userFields: [UserFields]? = nil, expansions: [Expansions]? = nil, tweetFields: [TweetFields]? = nil) {
                self.maxResults = maxResults
                self.paginationToken = paginationToken
                self.userFields = userFields
                self.expansions = expansions
                self.tweetFields = tweetFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(maxResults, forKey: "max_results")
                encoder.encode(paginationToken, forKey: "pagination_token")
                encoder.encode(userFields, forKey: "user.fields")
                encoder.encode(expansions, forKey: "expansions")
                encoder.encode(tweetFields, forKey: "tweet.fields")
                return encoder.items
            }
        }

        /// Mute User by User ID.
        ///
        /// Causes the User (in the path) to mute the target User. The User (in the path) must match the User context authorizing the request.
        public func post(_ body: TwitterAPI.MuteUserRequest? = nil) -> Request<TwitterAPI.MuteUserMutationResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.Users.WithID {
    public var ownedLists: OwnedLists {
        OwnedLists(path: path + "/owned_lists")
    }

    public struct OwnedLists {
        /// Path: `/2/users/{id}/owned_lists`
        public let path: String

        /// Get a User's Owned Lists.
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.Get2UsersIDOwnedListsResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var maxResults: Int?
            /// A 'long' pagination token.
            public var paginationToken: String?
            /// The fields available for a List object.
            ///
            /// Example: ["created_at", "description", "follower_count", "id", "member_count", "name", "owner_id", "private"]
            public var listFields: [ListFields]?
            /// The list of fields you can expand for a [List](#List) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["owner_id"]
            public var expansions: [Expansions]?
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?

            public enum ListFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case followerCount = "follower_count"
                case id
                case memberCount = "member_count"
                case name
                case ownerID = "owner_id"
                case `private`
            }

            public enum Expansions: String, Codable, CaseIterable {
                case ownerID = "owner_id"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public init(maxResults: Int? = nil, paginationToken: String? = nil, listFields: [ListFields]? = nil, expansions: [Expansions]? = nil, userFields: [UserFields]? = nil) {
                self.maxResults = maxResults
                self.paginationToken = paginationToken
                self.listFields = listFields
                self.expansions = expansions
                self.userFields = userFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(maxResults, forKey: "max_results")
                encoder.encode(paginationToken, forKey: "pagination_token")
                encoder.encode(listFields, forKey: "list.fields")
                encoder.encode(expansions, forKey: "expansions")
                encoder.encode(userFields, forKey: "user.fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Users.WithID {
    public var pinnedLists: PinnedLists {
        PinnedLists(path: path + "/pinned_lists")
    }

    public struct PinnedLists {
        /// Path: `/2/users/{id}/pinned_lists`
        public let path: String

        /// Get a User's Pinned Lists
        ///
        /// Get a User's Pinned Lists.
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.Get2UsersIDPinnedListsResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// The fields available for a List object.
            ///
            /// Example: ["created_at", "description", "follower_count", "id", "member_count", "name", "owner_id", "private"]
            public var listFields: [ListFields]?
            /// The list of fields you can expand for a [List](#List) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["owner_id"]
            public var expansions: [Expansions]?
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?

            public enum ListFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case followerCount = "follower_count"
                case id
                case memberCount = "member_count"
                case name
                case ownerID = "owner_id"
                case `private`
            }

            public enum Expansions: String, Codable, CaseIterable {
                case ownerID = "owner_id"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public init(listFields: [ListFields]? = nil, expansions: [Expansions]? = nil, userFields: [UserFields]? = nil) {
                self.listFields = listFields
                self.expansions = expansions
                self.userFields = userFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(listFields, forKey: "list.fields")
                encoder.encode(expansions, forKey: "expansions")
                encoder.encode(userFields, forKey: "user.fields")
                return encoder.items
            }
        }

        /// Pin a List
        ///
        /// Causes a User to pin a List.
        public func post(_ body: TwitterAPI.ListPinnedRequest) -> Request<TwitterAPI.ListPinnedResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.Users.WithID.PinnedLists {
    public func listID(_ listID: String) -> WithListID {
        WithListID(path: "\(path)/\(listID)")
    }

    public struct WithListID {
        /// Path: `/2/users/{id}/pinned_lists/{list_id}`
        public let path: String

        /// Unpin a List
        ///
        /// Causes a User to remove a pinned List.
        public var delete: Request<TwitterAPI.ListUnpinResponse> {
            .delete(path)
        }
    }
}

extension Paths.Users.WithID {
    public var retweets: Retweets {
        Retweets(path: path + "/retweets")
    }

    public struct Retweets {
        /// Path: `/2/users/{id}/retweets`
        public let path: String

        /// Causes the User (in the path) to retweet the specified Tweet.
        ///
        /// Causes the User (in the path) to retweet the specified Tweet. The User in the path must match the User context authorizing the request.
        public func post(_ body: TwitterAPI.UsersRetweetsCreateRequest? = nil) -> Request<TwitterAPI.UsersRetweetsCreateResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.Users.WithID.Retweets {
    public func sourceTweetID(_ sourceTweetID: String) -> WithSourceTweetID {
        WithSourceTweetID(path: "\(path)/\(sourceTweetID)")
    }

    public struct WithSourceTweetID {
        /// Path: `/2/users/{id}/retweets/{source_tweet_id}`
        public let path: String

        /// Causes the User (in the path) to unretweet the specified Tweet
        ///
        /// Causes the User (in the path) to unretweet the specified Tweet. The User must match the User context authorizing the request
        public var delete: Request<TwitterAPI.UsersRetweetsDeleteResponse> {
            .delete(path)
        }
    }
}

extension Paths.Users.WithID {
    public var timelines: Timelines {
        Timelines(path: path + "/timelines")
    }

    public struct Timelines {
        /// Path: `/2/users/{id}/timelines`
        public let path: String
    }
}

extension Paths.Users.WithID.Timelines {
    public var reverseChronological: ReverseChronological {
        ReverseChronological(path: path + "/reverse_chronological")
    }

    public struct ReverseChronological {
        /// Path: `/2/users/{id}/timelines/reverse_chronological`
        public let path: String

        /// User home timeline by User ID
        ///
        /// Returns Tweet objects that appears in the provided User ID's home timeline
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.Get2UsersIDTimelinesReverseChronologicalResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
            ///
            /// Example: "1346889436626259968"
            public var sinceID: String?
            /// Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
            ///
            /// Example: "1346889436626259968"
            public var untilID: String?
            public var maxResults: Int?
            /// A base36 pagination token.
            public var paginationToken: String?
            /// Example: ["replies", "retweets"]
            public var exclude: [Exclude]?
            public var startTime: Date?
            public var endTime: Date?
            /// The fields available for a Tweet object.
            ///
            /// Example: ["attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"]
            public var tweetFields: [TweetFields]?
            /// The list of fields you can expand for a [Tweet](#Tweet) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["attachments.media_keys", "attachments.poll_ids", "author_id", "entities.mentions.username", "geo.place_id", "in_reply_to_user_id", "referenced_tweets.id", "referenced_tweets.id.author_id"]
            public var expansions: [Expansions]?
            /// The fields available for a Media object.
            ///
            /// Example: ["alt_text", "duration_ms", "height", "media_key", "non_public_metrics", "organic_metrics", "preview_image_url", "promoted_metrics", "public_metrics", "type", "url", "variants", "width"]
            public var mediaFields: [MediaFields]?
            /// The fields available for a Poll object.
            ///
            /// Example: ["duration_minutes", "end_datetime", "id", "options", "voting_status"]
            public var pollFields: [PollFields]?
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?
            /// The fields available for a Place object.
            ///
            /// Example: ["contained_within", "country", "country_code", "full_name", "geo", "id", "name", "place_type"]
            public var placeFields: [PlaceFields]?

            public enum Exclude: String, Codable, CaseIterable {
                case replies
                case retweets
            }

            public enum TweetFields: String, Codable, CaseIterable {
                case attachments
                case authorID = "author_id"
                case contextAnnotations = "context_annotations"
                case conversationID = "conversation_id"
                case createdAt = "created_at"
                case entities
                case geo
                case id
                case inReplyToUserID = "in_reply_to_user_id"
                case lang
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case possiblySensitive = "possibly_sensitive"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case referencedTweets = "referenced_tweets"
                case replySettings = "reply_settings"
                case source
                case text
                case withheld
            }

            public enum Expansions: String, Codable, CaseIterable {
                case attachmentsMediaKeys = "attachments.media_keys"
                case attachmentsPollIDs = "attachments.poll_ids"
                case authorID = "author_id"
                case entitiesMentionsUsername = "entities.mentions.username"
                case geoPlaceID = "geo.place_id"
                case inReplyToUserID = "in_reply_to_user_id"
                case referencedTweetsID = "referenced_tweets.id"
                case referencedTweetsIDAuthorId = "referenced_tweets.id.author_id"
            }

            public enum MediaFields: String, Codable, CaseIterable {
                case altText = "alt_text"
                case durationMs = "duration_ms"
                case height
                case mediaKey = "media_key"
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case previewImageURL = "preview_image_url"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case type
                case url
                case variants
                case width
            }

            public enum PollFields: String, Codable, CaseIterable {
                case durationMinutes = "duration_minutes"
                case endDatetime = "end_datetime"
                case id
                case options
                case votingStatus = "voting_status"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public enum PlaceFields: String, Codable, CaseIterable {
                case containedWithin = "contained_within"
                case country
                case countryCode = "country_code"
                case fullName = "full_name"
                case geo
                case id
                case name
                case placeType = "place_type"
            }

            public init(sinceID: String? = nil, untilID: String? = nil, maxResults: Int? = nil, paginationToken: String? = nil, exclude: [Exclude]? = nil, startTime: Date? = nil, endTime: Date? = nil, tweetFields: [TweetFields]? = nil, expansions: [Expansions]? = nil, mediaFields: [MediaFields]? = nil, pollFields: [PollFields]? = nil, userFields: [UserFields]? = nil, placeFields: [PlaceFields]? = nil) {
                self.sinceID = sinceID
                self.untilID = untilID
                self.maxResults = maxResults
                self.paginationToken = paginationToken
                self.exclude = exclude
                self.startTime = startTime
                self.endTime = endTime
                self.tweetFields = tweetFields
                self.expansions = expansions
                self.mediaFields = mediaFields
                self.pollFields = pollFields
                self.userFields = userFields
                self.placeFields = placeFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(sinceID, forKey: "since_id")
                encoder.encode(untilID, forKey: "until_id")
                encoder.encode(maxResults, forKey: "max_results")
                encoder.encode(paginationToken, forKey: "pagination_token")
                encoder.encode(exclude, forKey: "exclude")
                encoder.encode(startTime, forKey: "start_time")
                encoder.encode(endTime, forKey: "end_time")
                encoder.encode(tweetFields, forKey: "tweet.fields")
                encoder.encode(expansions, forKey: "expansions")
                encoder.encode(mediaFields, forKey: "media.fields")
                encoder.encode(pollFields, forKey: "poll.fields")
                encoder.encode(userFields, forKey: "user.fields")
                encoder.encode(placeFields, forKey: "place.fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Users.WithID {
    public var tweets: Tweets {
        Tweets(path: path + "/tweets")
    }

    public struct Tweets {
        /// Path: `/2/users/{id}/tweets`
        public let path: String

        /// User Tweets timeline by User ID
        ///
        /// Returns a list of Tweets authored by the provided User ID
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.Get2UsersIDTweetsResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
            ///
            /// Example: "1346889436626259968"
            public var sinceID: String?
            /// Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
            ///
            /// Example: "1346889436626259968"
            public var untilID: String?
            public var maxResults: Int?
            /// A base36 pagination token.
            public var paginationToken: String?
            /// Example: ["replies", "retweets"]
            public var exclude: [Exclude]?
            public var startTime: Date?
            public var endTime: Date?
            /// The fields available for a Tweet object.
            ///
            /// Example: ["attachments", "author_id", "context_annotations", "conversation_id", "created_at", "entities", "geo", "id", "in_reply_to_user_id", "lang", "non_public_metrics", "organic_metrics", "possibly_sensitive", "promoted_metrics", "public_metrics", "referenced_tweets", "reply_settings", "source", "text", "withheld"]
            public var tweetFields: [TweetFields]?
            /// The list of fields you can expand for a [Tweet](#Tweet) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["attachments.media_keys", "attachments.poll_ids", "author_id", "entities.mentions.username", "geo.place_id", "in_reply_to_user_id", "referenced_tweets.id", "referenced_tweets.id.author_id"]
            public var expansions: [Expansions]?
            /// The fields available for a Media object.
            ///
            /// Example: ["alt_text", "duration_ms", "height", "media_key", "non_public_metrics", "organic_metrics", "preview_image_url", "promoted_metrics", "public_metrics", "type", "url", "variants", "width"]
            public var mediaFields: [MediaFields]?
            /// The fields available for a Poll object.
            ///
            /// Example: ["duration_minutes", "end_datetime", "id", "options", "voting_status"]
            public var pollFields: [PollFields]?
            /// The fields available for a User object.
            ///
            /// Example: ["created_at", "description", "entities", "id", "location", "name", "pinned_tweet_id", "profile_image_url", "protected", "public_metrics", "url", "username", "verified", "withheld"]
            public var userFields: [UserFields]?
            /// The fields available for a Place object.
            ///
            /// Example: ["contained_within", "country", "country_code", "full_name", "geo", "id", "name", "place_type"]
            public var placeFields: [PlaceFields]?

            public enum Exclude: String, Codable, CaseIterable {
                case replies
                case retweets
            }

            public enum TweetFields: String, Codable, CaseIterable {
                case attachments
                case authorID = "author_id"
                case contextAnnotations = "context_annotations"
                case conversationID = "conversation_id"
                case createdAt = "created_at"
                case entities
                case geo
                case id
                case inReplyToUserID = "in_reply_to_user_id"
                case lang
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case possiblySensitive = "possibly_sensitive"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case referencedTweets = "referenced_tweets"
                case replySettings = "reply_settings"
                case source
                case text
                case withheld
            }

            public enum Expansions: String, Codable, CaseIterable {
                case attachmentsMediaKeys = "attachments.media_keys"
                case attachmentsPollIDs = "attachments.poll_ids"
                case authorID = "author_id"
                case entitiesMentionsUsername = "entities.mentions.username"
                case geoPlaceID = "geo.place_id"
                case inReplyToUserID = "in_reply_to_user_id"
                case referencedTweetsID = "referenced_tweets.id"
                case referencedTweetsIDAuthorId = "referenced_tweets.id.author_id"
            }

            public enum MediaFields: String, Codable, CaseIterable {
                case altText = "alt_text"
                case durationMs = "duration_ms"
                case height
                case mediaKey = "media_key"
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case previewImageURL = "preview_image_url"
                case promotedMetrics = "promoted_metrics"
                case publicMetrics = "public_metrics"
                case type
                case url
                case variants
                case width
            }

            public enum PollFields: String, Codable, CaseIterable {
                case durationMinutes = "duration_minutes"
                case endDatetime = "end_datetime"
                case id
                case options
                case votingStatus = "voting_status"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case entities
                case id
                case location
                case name
                case pinnedTweetID = "pinned_tweet_id"
                case profileImageURL = "profile_image_url"
                case protected
                case publicMetrics = "public_metrics"
                case url
                case username
                case verified
                case withheld
            }

            public enum PlaceFields: String, Codable, CaseIterable {
                case containedWithin = "contained_within"
                case country
                case countryCode = "country_code"
                case fullName = "full_name"
                case geo
                case id
                case name
                case placeType = "place_type"
            }

            public init(sinceID: String? = nil, untilID: String? = nil, maxResults: Int? = nil, paginationToken: String? = nil, exclude: [Exclude]? = nil, startTime: Date? = nil, endTime: Date? = nil, tweetFields: [TweetFields]? = nil, expansions: [Expansions]? = nil, mediaFields: [MediaFields]? = nil, pollFields: [PollFields]? = nil, userFields: [UserFields]? = nil, placeFields: [PlaceFields]? = nil) {
                self.sinceID = sinceID
                self.untilID = untilID
                self.maxResults = maxResults
                self.paginationToken = paginationToken
                self.exclude = exclude
                self.startTime = startTime
                self.endTime = endTime
                self.tweetFields = tweetFields
                self.expansions = expansions
                self.mediaFields = mediaFields
                self.pollFields = pollFields
                self.userFields = userFields
                self.placeFields = placeFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(sinceID, forKey: "since_id")
                encoder.encode(untilID, forKey: "until_id")
                encoder.encode(maxResults, forKey: "max_results")
                encoder.encode(paginationToken, forKey: "pagination_token")
                encoder.encode(exclude, forKey: "exclude")
                encoder.encode(startTime, forKey: "start_time")
                encoder.encode(endTime, forKey: "end_time")
                encoder.encode(tweetFields, forKey: "tweet.fields")
                encoder.encode(expansions, forKey: "expansions")
                encoder.encode(mediaFields, forKey: "media.fields")
                encoder.encode(pollFields, forKey: "poll.fields")
                encoder.encode(userFields, forKey: "user.fields")
                encoder.encode(placeFields, forKey: "place.fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Users {
    public func sourceUserID(_ sourceUserID: String) -> WithSourceUserID {
        WithSourceUserID(path: "\(path)/\(sourceUserID)")
    }

    public struct WithSourceUserID {
        /// Path: `/2/users/{source_user_id}`
        public let path: String
    }
}

extension Paths.Users.WithSourceUserID {
    public var blocking: Blocking {
        Blocking(path: path + "/blocking")
    }

    public struct Blocking {
        /// Path: `/2/users/{source_user_id}/blocking`
        public let path: String
    }
}

extension Paths.Users.WithSourceUserID.Blocking {
    public func targetUserID(_ targetUserID: String) -> WithTargetUserID {
        WithTargetUserID(path: "\(path)/\(targetUserID)")
    }

    public struct WithTargetUserID {
        /// Path: `/2/users/{source_user_id}/blocking/{target_user_id}`
        public let path: String

        /// Unblock User by User ID
        ///
        /// Causes the source User to unblock the target User. The source User must match the User context authorizing the request
        public var delete: Request<TwitterAPI.BlockUserMutationResponse> {
            .delete(path)
        }
    }
}

extension Paths.Users.WithSourceUserID {
    public var following: Following {
        Following(path: path + "/following")
    }

    public struct Following {
        /// Path: `/2/users/{source_user_id}/following`
        public let path: String
    }
}

extension Paths.Users.WithSourceUserID.Following {
    public func targetUserID(_ targetUserID: String) -> WithTargetUserID {
        WithTargetUserID(path: "\(path)/\(targetUserID)")
    }

    public struct WithTargetUserID {
        /// Path: `/2/users/{source_user_id}/following/{target_user_id}`
        public let path: String

        /// Unfollow User
        ///
        /// Causes the source User to unfollow the target User. The source User must match the User context authorizing the request
        public var delete: Request<TwitterAPI.UsersFollowingDeleteResponse> {
            .delete(path)
        }
    }
}

extension Paths.Users.WithSourceUserID {
    public var muting: Muting {
        Muting(path: path + "/muting")
    }

    public struct Muting {
        /// Path: `/2/users/{source_user_id}/muting`
        public let path: String
    }
}

extension Paths.Users.WithSourceUserID.Muting {
    public func targetUserID(_ targetUserID: String) -> WithTargetUserID {
        WithTargetUserID(path: "\(path)/\(targetUserID)")
    }

    public struct WithTargetUserID {
        /// Path: `/2/users/{source_user_id}/muting/{target_user_id}`
        public let path: String

        /// Unmute User by User ID
        ///
        /// Causes the source User to unmute the target User. The source User must match the User context authorizing the request
        public var delete: Request<TwitterAPI.MuteUserMutationResponse> {
            .delete(path)
        }
    }
}

public enum Paths {}
